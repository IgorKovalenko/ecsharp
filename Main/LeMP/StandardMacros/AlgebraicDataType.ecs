using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Loyc;
using Loyc.Syntax;
using Loyc.Collections;

namespace LeMP
{
	using S = CodeSymbols;

	public partial class StandardMacros
	{
		static readonly Symbol __alt = (Symbol)"#alt";
		static readonly Symbol _alt = (Symbol)"alt";

		[LexicalMacro(@"e.g. alt class Tree<T> { alt Node(Tree<T> Left, Tree<T> Right); alt Leaf(T Value); }",
			"Expands a short description of an 'algebraic data type' into a set of classes with a common base class.", 
			"#class", Mode = MacroMode.Passive | MacroMode.Normal)]
		public static LNode AlgebraicDataType(LNode classDecl, IMacroContext context)
		{
			int i;
			matchCode(classDecl) {
				case {
					[$(..attrs[(i = attrs.IndexWhere(a => a.IsIdNamed(__alt))) > -1])] 
					class $baseName : $(..baseTypes) {
						$(..body);
					}
				}:
					attrs = attrs.RemoveAt(i);
					var adt = new AltType(attrs, baseName, baseTypes, null);
					adt.ScanClassBody(body);
					var output = new RVList<LNode>();
					adt.GenerateOutput(ref output);
					return quote(#splice($(..output)));
			}
			return null;
		}

		// Info about one variant of an ADT
		class AltType {
			public AltType(private RVList<LNode> _typeAttrs, public LNode TypeName, public RVList<LNode> BaseTypes, public AltType ParentType)
			{
				if (ParentType != null)
					BaseTypes.Add(ParentType.TypeName);
				//matchCode (TypeName) {
				//	case $stem<$(..a)>, $stem: 
				//		_typeNameStem = stem;
				//		_genericArgs = a; 
				//}
				{	// Above matchCode expanded:
					LNode stem;
					RVList<LNode> a = default(RVList<LNode>);
					if (TypeName.CallsMin(CodeSymbols.Of, 1) && (stem = TypeName.Args[0]) != null && (a = new RVList<LNode>(TypeName.Args.Slice(1))).IsEmpty | true || (stem = TypeName) != null) {
						_typeNameStem = stem;
						_genericArgs = a;
					}
				}
			}

			LNode _typeNameStem;
			RVList<LNode> _genericArgs = new RVList<LNode>();
			List<AltType> _children = new List<AltType>();
			internal List<AdtParam> Parts = new List<AdtParam>();
			RVList<LNode> _constructorAttrs;
			RVList<LNode> _extraConstrLogic;
			RVList<LNode> _classBody = new RVList<LNode>();

			public void AddParts(RVList<LNode> parts)
			{
				foreach (var part in parts)
					Parts.Add(new AdtParam(part, this));
			}
			public void ScanClassBody(RVList<LNode> body)
			{
				foreach (var stmt in body) {
					int i;
					matchCode (stmt) {
					case { [$(..attrs)] alt $altName($(..parts));                     }, 
						 { [$(..attrs)] alt $altName($(..parts)) { $(..childBody); }  }:
						LNode genericAltName = altName;
						matchCode (altName) {
							case $_<$(.._)>: // do nothing
							default:
								if (_genericArgs.Count > 0)
									genericAltName = quote($altName<$(.._genericArgs)>);
						}
						var child = new AltType(attrs, genericAltName, LNode.List(), this);
						child.AddParts(parts);
						child.ScanClassBody(childBody);
						_children.Add(child);
					case [$(..attrs[(i = attrs.IndexWhere(a => a.IsIdNamed(__alt))) > -1])] 
					     #cons($_, this, #($(..parts)), $(..rest[rest.Count <= 1])):
						attrs.RemoveAt(i);
						_constructorAttrs.AddRange(attrs);
						if (rest.Count > 0 && rest[0].Calls(S.Braces))
							_extraConstrLogic.AddRange(rest[0].Args);
						AddParts(parts);
					default:
						_classBody.Add(stmt);
					}
				}
			}
			// Generates a class declaration for the current alt and its subtypes
			public void GenerateOutput(ref RVList<LNode> list)
			{
				bool isAbstract = _typeAttrs.Any(a => a.IsIdNamed(S.Abstract));
				
				var baseParts = new List<AdtParam>();
				for (var type = ParentType; type != null; type = type.ParentType)
					baseParts.InsertRange(0, type.Parts);
				var allParts = baseParts.Concat(Parts);

				var initialization = Parts.Select(p => quote { this.$(p.NameId) = $(p.NameId); }).ToList();
				if (baseParts.Count > 0)
					initialization.Insert(0, F.Call(S.Base, baseParts.Select(p => p.NameId)));

				var args = new RVList<LNode>(allParts.Select(p => p.OriginalDecl));
				if (!_constructorAttrs.Any(a => a.IsIdNamed(S.Public)))
					_constructorAttrs.Add(F.Id(S.Public));
				LNode constructor = quote {
					[$(.._constructorAttrs)] 
					#cons(@``, $_typeNameStem, #($(..args)), {
						$(..initialization);
						$(.._extraConstrLogic);
					});
				};

				var outBody = new RVList<LNode>();
				outBody.Add(constructor);
				outBody.AddRange(Parts.Select(p => p.GetFieldDecl()));
				outBody.AddRange(baseParts.Select(p => GetWithFn(p, isAbstract, S.Override, allParts)));
				outBody.AddRange(Parts.Select(p => GetWithFn(p, isAbstract, _children.Count > 0 ? S.Virtual : null, allParts)));
				outBody.AddRange(Parts.WithIndexes()
					.Where(kvp => kvp.Value.NameId.Name.Name != "Item" + (baseParts.Count + kvp.Key + 1))
					.Select(kvp => kvp.Value.GetItemDecl(baseParts.Count + kvp.Key + 1)));
				outBody.AddRange(_classBody);

				list.Add(quote {
					[$(.._typeAttrs)] 
					class $TypeName : $(..BaseTypes) {
						$(..outBody);
					}
				});
				if (_genericArgs.Count > 0 && Parts.Count > 0) {
					var argNames = allParts.Select(p => p.NameId);
					list.Add(quote {
						[$(.._typeAttrs)] static partial class $_typeNameStem
						{
							public static $TypeName New<$(.._genericArgs)>($(..args))
								{ return new $TypeName($(..argNames)); }
						}
					});
				}
				foreach (var child in _children)
					child.GenerateOutput(ref list);
			}
			public LNode GetWithFn(AdtParam part, bool isAbstract, Symbol virtualOverride, IEnumerable<AdtParam> allParts)
			{
				LNode genericClassName = this.TypeName;
				int totalParts = allParts.Count();
				var withField = F.Id("With" + part.NameId.Name);
				
				var args = LNode.List();
				foreach(AdtParam otherPart in allParts) {
					if (part == otherPart)
						args.Add(F.Id("newValue"));
					else
						args.Add(otherPart.NameId);
				}
				
				var attrs = new RVList<LNode>(F.Id(S.Public));
				if (isAbstract)
					attrs.Add(F.Id(S.Abstract));
				if (virtualOverride != null && (!isAbstract || virtualOverride == S.Override))
					attrs.Add(F.Id(virtualOverride));

				LNode method;
				LNode type = part.Type;
				LNode retType = part.ContainingType.TypeName;
				if (isAbstract) {
					method = quote {
						[$(..attrs)] $retType $withField([$(..part.OriginalDecl.Attrs)] $type newValue);
					};
				} else {
					method = quote {
						[$(..attrs)] $retType $withField([$(..part.OriginalDecl.Attrs)] $type newValue) 
							{ return new $genericClassName($(..args)); }
					};
				}
				return method;
			}
		}

		// Info about one parameter of one ADT
		class AdtParam
		{
			public AdtParam(public LNode OriginalDecl, public AltType ContainingType)
			{
				if (!OriginalDecl.Calls(S.Var, 2))
					throw new LogException(OriginalDecl, "alt: Expected a variable declaration");
				Type = OriginalDecl.Args[0];
				NameId = OriginalDecl.Args[1];
				if (NameId.Calls(S.Assign, 2))
					NameId = NameId.Args[0];
				if (!NameId.IsId)
					throw new LogException(NameId, "alt: Expected a simple variable name");
			}

			public readonly LNode Type;
			public readonly LNode NameId;
			
			public LNode GetFieldDecl() {
				return quote {
					public $Type $NameId { get; private set; }
				};
			}
			public LNode GetItemDecl(int itemNum) {
				LNode ItemN = F.Id("Item" + itemNum);
				return quote {
					// ItemN properties are used by the code generated for pattern matching
					[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
					public $Type $ItemN { get { return $NameId; } }
				};
			}
		}
	}
}
