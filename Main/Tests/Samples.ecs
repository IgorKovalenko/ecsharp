#importMacros(Loyc.LLPG);
using System(, .Collections(, .Generic), .Text, .Linq);
using Loyc(, .Collections, .MiniTest, .Syntax (, .Lexing));

namespace Samples {
	using ADT;

	[TestFixture]
	partial class Samples : Assert
	{
		public static void Run()
		{
			RunTests.Run(new Samples());
		}
		[Test] public void ContainsTest()
		{
			var tree = Node.New(5, Node.New(1, null, Leaf.New(3)), Node.New(9, Leaf.New(7), null));
			for (int i = 0; i <= 12; i++)
				if (tree.Contains(i))
					Console.Write(" {0}",i);
			Console.WriteLine(" were found");
		}
		[Test] public void RangeTest()
		{
			IsTrue(5 in 4..6);
			IsTrue(6 in 5...6);
			IsFalse(5 in 4..5);
			IsFalse(4 in 4..3);
			AreEqual(10, (1..5).Sum());
			AreEqual(15, (1...5).Sum());
			AreEqual(0, (1..1).Sum());
			AreEqual(0, (1...0).Sum());
		}
		[Test] public void PrintAllTheNames()
		{
			try {
				PlayPen.PrintAllTheNames(@"..\..\Core\Loyc.Essentials\Utilities");
			} catch {}
		}
		static void FavoriteNumberGame()
		{
			Console.Write("What's your favorite number? ");
			match(int.Parse(Console.ReadLine())) {
				case 7, 777: Console.WriteLine("You lucky bastard!");
				case 5, 10: Console.WriteLine("I have that many fingers too!");
				case 0, 1: Console.WriteLine("What? Nobody picks that!");
				case 2, 3: Console.WriteLine("Yeah, I guess you deal with those a lot.");
				case 12: Console.WriteLine("I prefer a baker's dozen.");
				case 666, 13: Console.WriteLine("Isn't that bad luck though?");
				case 1..<10: Console.WriteLine("Kind of boring, don't you think?");
				case 11, 13, 17, 19, 23, 29: Console.WriteLine("A prime choice.");
				case 10...99: Console.WriteLine("Well... it's got two digits, I'll give you that much.");
				case ...-1: Console.WriteLine("Oh, don't be so negative.");
				default: Console.WriteLine("What are you, high? Like that number?");
			}
		}
	}
}
namespace ADT
{
	// Example of ADT from "C# Gets Pattern Matching & Algebraic Data Types"
	public alt class BinaryTree<T> where T: IComparable<T>
	{
		alt this(T Value);
		alt Node(BinaryTree<T> Left, BinaryTree<T> Right)
		{
			public alt this()
			{
				if (Left == null && Right == null) throw new ArgumentNullException("Both children");
			}
			public override bool Contains(T item)
			{
				int cmp = Compare(item, Value);
				if (cmp < 0)
					return Left != null && Left.Contains(item);
				else if (cmp > 0)
					return Right != null && Right.Contains(item);
				else
					return true;
			}
		}
	
		public virtual bool Contains(T item)
		{
			return Compare(Value, item) == 0;
		}
		internal static int Compare(T a, T b)
		{	// It's null's fault that this method exists.
			if (a != null)
				return a.CompareTo(b);
			else if (b != null)
				return -a.CompareTo(a);
			else
				return 0;
		}
	}
	public static class Leaf {
		public static BinaryTree<T> New<T>(T item) 
			where T: IComparable<T> 
			{ return new BinaryTree<T>(item); }
	}

	public abstract alt class Rectangle {
		alt this(int X, int Y, int Width, int Height);
	}
	public abstract alt class Widget {
		alt this(Rectangle Location) {
			if (Location == null) throw new ArgumentNullException("Location");
		}
		alt Button(string Text) { }
		alt TextBox(string Text) { }
		abstract alt StringListWidget(string[] subItems) {
			alt ComboBox();
			alt ListBox();
		}
		public abstract alt Container() {
			alt TabControl(TabPage[] Children);
			alt Panel(Widget[] Children) {
				alt TabPage(string Title);
			}
		}
	}
}

// Example from LLLPG article #5
struct EmailAddress
{
  public EmailAddress(public UString UserName, public UString Domain) {}
  public override string ToString() { return UserName + "@" + Domain; }

  LLLPG (lexer(inputSource(src), inputClass(LexerSource)));
  // LexerSource provides the APIs expected by LLLPG. This is
  // static to avoid reallocating the helper object for each email.
  [ThreadStatic] static LexerSource<UString> src;

  static rule UsernameChars(LexerSource<UString> src) @{
    ('a'..'z'|'A'..'Z'|'0'..'9'|'!'|'#'|'$'|'%'|'&'|'\''|
    '*'|'+'|'/'|'='|'?'|'^'|'_'|'`'|'{'|'|'|'}'|'~'|'-')+
  };
  static rule DomainCharSeq(LexerSource<UString> src) @{
           ('a'..'z'|'A'..'Z'|'0'..'9')
    ( '-'? ('a'..'z'|'A'..'Z'|'0'..'9') )*
  };

  /// <summary>Parses email addresses according to RFC 5322, not including 
  /// quoted usernames or non-ASCII addresses (TODO: support Unicode).</summary>
  /// <exception cref="FormatException">The input is not a legal email address.</exception>
  public static rule EmailAddress Parse(UString email)
  {
    if (src == null)
      src = new LexerSource<UString>(email, "", 0, false);
    else
      src.Reset(email, "", 0, false); // re-use old object
    
    @{ UsernameChars(src) ('.' UsernameChars(src))* };
    int at = src.InputPosition;
    UString userName = email.Substring(0, at);
    
    @[ '@' DomainCharSeq(src) ('.' DomainCharSeq(src))* EOF ];
    UString domain = email.Substring(at + 1);
    return new EmailAddress(userName, domain);
  }
}
