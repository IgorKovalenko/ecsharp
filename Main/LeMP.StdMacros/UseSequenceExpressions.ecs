using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Loyc;
using Loyc.Syntax;
using Loyc.Collections;
using S = Loyc.Syntax.CodeSymbols;
using Loyc.Ecs;

namespace LeMP
{
	partial class StandardMacros
	{
		static readonly Symbol __runSequence = (Symbol) "#runSequence";
		static readonly Symbol _useSequenceExpressionsIsRunning = (Symbol) "#useSequenceExpressionsIsRunning";

		[LexicalMacro("#runSequence { Stmts; };",
			"Allows #runSequence at brace-scope without the use of #useSequenceExpressions",
			"#runSequence", Mode = MacroMode.Passive)]
		public static LNode runSequence(LNode node, IMacroContext context)
		{
			if (context.Parent.Calls(S.Braces))
				return node.With(S.Splice, MaybeRemoveNoOpFromRunSeq(node.Args));
			if (!context.ScopedProperties.ContainsKey(_useSequenceExpressionsIsRunning))
				Reject(context, node, "#useSequenceExpressions is required to make #runSequence work");
			return null;
		}

		public static VList<LNode> MaybeRemoveNoOpFromRunSeq(VList<LNode> runSeq)
		{
			// Delete final no-op in case of e.g. Foo()::id; => #runSequence(var id = Foo(); id)
			if (runSeq.Count > 1 && runSeq.Last.IsId)
				return runSeq.WithoutLast(1);
			return runSeq;
		}

		[LexicalMacro("#useSequenceExpressions; ... if (Foo.Bar()::b.Baz != null) b.Baz.Method(); ...", 
			"Enables the use of variable-declaration and #runSequence expressions, including the quick-binding operator `::` and the `with` expression, in the code that follows."
			+"Technically this allows any executable code in an expression context, such as while and for-loops, "
			+"but its name comes from the fact that it is usually used to allow variable declarations. "
			+"#useSequenceExpressions expects to be used in a declaration context, "
			+"e.g. at class or namespace level, not within a function.",
			"#useSequenceExpressions", Mode = MacroMode.NoReprocessing)]
		public static LNode useSequenceExpressions(LNode node, IMacroContext context)
		{
			(var args, var body) = context.GetArgsAndBody(true);
			if (args.Count > 0)
				context.Write(Severity.Error, node[1], "#useSequenceExpressions does not support arguments.");

			{
				context.ScopedProperties[_useSequenceExpressionsIsRunning] = G.BoxedTrue;
				on_finally { context.ScopedProperties.Remove(_useSequenceExpressionsIsRunning); };
				body = context.PreProcess(body);
			}
			var ers = new EliminateRunSequences(context);
			return ers.EliminateSequenceExpressions(body, true).AsLNode(S.Splice);
		}

		class EliminateRunSequences
		{
			public this(public IMacroContext Context) {}
			LNode[] _arrayOf1 = new LNode[1];
			
			public VList<LNode> EliminateSequenceExpressions(VList<LNode> stmts, bool isDeclContext)
			{
				return stmts.SmartSelectMany(stmt => {
					// Optimization: scan find out whether this construct has any block 
					// expressions. If not, skip it.
					/*hasBlockExprs = false;
					stmt.ReplaceRecursive(new Func<LNode, Maybe<LNode>>(n => {
						if (!hasBlockExprs)
							hasBlockExprs = n.IsCall && (
								(n.Calls(S.ColonColon, 2) && n.Args[1].IsId) ||
								(n.Calls(S.Var, 2) && n.AttrNamed(S.Out) != null) ||
								(n.Calls(S.In, 2) && n.Args[1].Calls(S.Braces)));
						return hasBlockExprs ? n : null;
					}));
					if (!hasBlockExprs)
						return stmt;
					*/
					LNode result = EliminateSequenceExpressions(stmt, isDeclContext);
					if (result != stmt) {
						VList<LNode> results;
						if (result.Calls(__runSequence)) {
							results = MaybeRemoveNoOpFromRunSeq(result.Args);
							return results;
						}
					}
					_arrayOf1[0] = result;
					return _arrayOf1;
				});
			}

			public LNode EliminateSequenceExpressions(LNode stmt, bool isDeclContext)
			{
				LNode retType, name, argList, bases, body, initValue;
				if (EcsValidators.SpaceDefinitionKind(stmt, out name, out bases, out body) != null) {
					// Space definition: class, struct, etc.
					return body == null ? stmt : stmt.WithArgChanged(2, EliminateSequenceExpressions(body, true));
				} else if (EcsValidators.MethodDefinitionKind(stmt, out retType, out name, out argList, out body, true) != null) {
					// Method definition
					return body == null ? stmt : stmt.WithArgChanged(3, EliminateSequenceExpressions(body, false));
				} else if (EcsValidators.IsPropertyDefinition(stmt, out retType, out name, out argList, out body, out initValue)) {
					// Property definition
					stmt = stmt.WithArgChanged(3, 
						body.WithArgs(part => {
							if (part.ArgCount == 1 && part[0].Calls(S.Braces))
								part = part.WithArgChanged(0, EliminateSequenceExpressions(part[0], false));
							return part;
						}));
					if (initValue != null) {
						var initMethod = EliminateRunSeqFromInitializer(retType, name, ref initValue);
						if (initMethod != null) {
							stmt = stmt.WithArgChanged(4, initValue);
							return quote(#runSequence($stmt, $initMethod));
						}
					}
					return stmt;
				} else if (!isDeclContext) {
					return EliminateSequenceExpressionsInExecStmt(stmt);
				} else if (stmt.CallsMin(S.Var, 2)) {
					// Eliminate blocks from field member
					var results = new List<LNode> { stmt };
					var vars = stmt.Args;
					var varType = vars[0];
					for (int i = 1; i < vars.Count; i++) {
						var var = vars[i];
						matchCode (var) {
							case $(ref name) = $(ref initValue):
								var initMethod = EliminateRunSeqFromInitializer(varType, name, ref initValue);
								if (initMethod != null) {
									results.Add(initMethod);
									vars[i] = vars[i].WithArgChanged(1, initValue);
								}
						}
					}
					if (results.Count > 1) {
						results[0] = stmt.WithArgs(vars);
						return LNode.List(results).AsLNode(__runSequence);
					}
					return stmt;
				} else
					return stmt;
			}

			LNode EliminateSequenceExpressionsInExecStmt(LNode stmt)
			{
				matchCode (stmt) {
					case { { $(..._); } }: // braced block
						return stmt.WithArgs(EliminateSequenceExpressions(stmt.Args, false));
					case { if ($cond) $(...blocks); }: // `blocks` includes else clause, if any 
						return ProcessBlockCallStmt(stmt, 1);
					// TODO
					// case { while ($cond) $block; }: 
					// case { do $block; while($cond); }:
					// case { for ($init; $cond; $inc) $block; }:
					case { [$(...attrs)] $type $name = $initValue; }:
						initValue = BubbleUpBlocks(initValue);
						matchCode (initValue) {
							case #runSequence($(...stmts), $last):
								return quote(#runSequence($(...stmts), [$(...attrs)] $type $name = $last));
						}
					default:
						if (stmt.HasSpecialName && stmt.ArgCount >= 1 && stmt.Args.Last.Calls(S.Braces)) {
							return ProcessBlockCallStmt(stmt, stmt.ArgCount - 1);
						} else {
							// Ordinary expression statement
							return BubbleUpBlocks(stmt, isStmtLevel: true);
						}
				}
				return stmt;
			}

			LNode ProcessBlockCallStmt(LNode stmt, int childStmtsStartAt)
			{
				List<LNode> childStmts = stmt.Slice(childStmtsStartAt).ToList();
				LNode partialStmt = stmt.WithArgs(stmt.Args.First(childStmtsStartAt));
				VList<LNode> advanceSequence;
				if (ProcessBlockCallStmt2(ref partialStmt, out advanceSequence, childStmts)) {
					stmt = partialStmt.PlusArgs(childStmts);
					if (advanceSequence.Count != 0)
						return quote {{ $(...advanceSequence); $stmt; }};
					return stmt; // only the child statements changed
				} else
					return stmt; // no changes
			}
			
			// This is called to process the "front" of a block call, e.g.
			// #if(cond, {T}, {F}) => partialStmt = #if(cond); childStmts = {{T}, {F}}
			// Returns true if anything changed (i.e. sequence expr detected)
			bool ProcessBlockCallStmt2(ref LNode partialStmt, out VList<LNode> advanceSequence, List<LNode> childStmts)
			{
				// Process the child statement(s)
				bool childChanged = false;
				for (int i = 0; i < childStmts.Count; i++) {
					var oldChild = childStmts[i];
					childStmts[i] = EliminateSequenceExpressionsInChildStmt(oldChild);
					childChanged |= (oldChild != childStmts[i]);
				}

				// Process the normal arguments
				(advanceSequence, partialStmt) = BubbleUp_GeneralCall2(partialStmt);
				return childChanged || !advanceSequence.IsEmpty;
			}

			LNode EliminateSequenceExpressionsInChildStmt(LNode stmt)
			{
				stmt = EliminateSequenceExpressionsInExecStmt(stmt);
				if (stmt.Calls(__runSequence))
					return stmt.With(S.Braces, MaybeRemoveNoOpFromRunSeq(stmt.Args));
				return stmt;
			}

			/// Eliminates run sequence(s) in a field initializer expression.
			/// If any are found, a method is returned to encapsulate the 
			/// initialization code, e.g.
			///   expr on entry: Foo()::foo.x + foo.y
			///   return value:  static retType fieldName_initializer() {
			///                      var foo = Foo();
			///                      return foo.x + foo.y;
			///                  }
			///   expr on exit:  fieldName_initializer()
			LNode EliminateRunSeqFromInitializer(LNode retType, LNode fieldName, ref LNode expr)
			{
				expr = BubbleUpBlocks(expr);
				if (expr.CallsMin(__runSequence, 1)) {
					var statements = expr.Args.WithoutLast(1);
					var finalResult = expr.Args.Last;
					
					LNode methodName = F.Id(KeyNameComponentOf(fieldName).Name + "_initializer");
					expr = quote( $methodName() );
					return quote {
						static $retType $methodName() {
							$(...statements);
							return $finalResult;
						}
					};
				} else
					return null; // most common case
			}

			// This method's main goal is to move #runSequence from child nodes to outer nodes:
			//   Foo(a, #runSequence(b(), c())) => #runSequence(var a_10 = a; b(); Foo(a_10, c()));
			// It also converts variable declarations, e.g. 
			//   Foo()::foo => #runSequence(var foo = Foo(), foo)
			LNode BubbleUpBlocks(LNode expr, bool isStmtLevel = false)
			{
				if (!expr.IsCall)
					return expr;

				LNode result = null;
				if (!isStmtLevel) {
					matchCode (expr) {
					case { { $(..._); } }: // braced block
						Context.Write(Severity.Error, expr, "A braced block is not supported directly within an expression. Did you mean to use `#runSequence {...}`?");
						result = expr;

					// A variable declaration with no initializer and an `out` attribute attached
					case { [$(...(attrs [#.NodeNamed(S.Out) != null]))]
							$varType $(varName [#.IsId]); }:
						if (varType.IsIdNamed(S.Missing))
							Context.Write(Severity.Error, expr, "#useSequenceExpressions: the data type of this variable declaration cannot be inferred and must be stated explicitly.");
						result = quote( #runSequence($(expr.WithoutAttrNamed(S.Out)), $varName) );

					// A variable declaration with an initializer (may have a `ref` attribute 
					// attached, which should be transferred to the final expression)
					case [$(...attrs)] $varType $varName = $value,
						 [$(...attrs)] $(value [IsQuickBindLhs(#)]) :: $(varName [#.IsId]):
						result = ConvertVarDeclToRunSequence(attrs, varType ?? F.Missing, varName, value);
					}
				}
				if (result == null) {
					if (expr.Calls(__runSequence))
						result = expr;
					else
						result = BubbleUp_GeneralCall(expr);
				}

				// #runSequences can be nested by the user or produced by BubbleUp_GeneralCall,
				// so process the code inside #runSequence too
				if (result.Calls(__runSequence))
					return result.WithArgs(EliminateSequenceExpressions(result.Args, false));
				else
					return result;
			}

			// Bubbles up a call, e.g. 
			//   Foo(x, #runSequence(y, z)) => #runSequence(var x_10 = x, y, Foo(x_10, z)) 
			LNode BubbleUp_GeneralCall(LNode expr)
			{
				(var combinedSequence, expr) = BubbleUp_GeneralCall2(expr);
				if (combinedSequence.Count != 0)
					return quote( #runSequence($(...combinedSequence), $expr) );
				else
					return expr;
			}
			// Bubbles up a call. The returned pair consists of 
			// 1. A sequence of statements to run before the call
			// 2. The call with all (outer) #runSequences removed
			Pair<VList<LNode>, LNode> BubbleUp_GeneralCall2(LNode expr)
			{
				var target = expr.Target;
				var args = expr.Args;
				var combinedSequence = LNode.List();
					
				target = BubbleUpBlocks(target);
				if (target.CallsMin(__runSequence, 1)) {
					combinedSequence = target.Args.WithoutLast(1);
					expr = expr.WithTarget(target.Args.Last);
				}

				args = args.SmartSelect(arg => BubbleUpBlocks(arg));
				int lastRunSeq = args.LastIndexWhere(a => a.CallsMin(__runSequence, 1));
				if (lastRunSeq >= 0) {
					if (lastRunSeq > 0 && 
						(  args.Count == 2 && (target.IsIdNamed(S.And) || target.IsIdNamed(S.Or))
						|| args.Count == 3 && target.IsIdNamed(S.QuestionMark))) {
						Context.Write(Severity.Error, target, 
							"#useSequenceExpressions is not designed to support sequences or variable declarations on the right-hand side of the `&&`, `||` or `?` operators. The generated code will be incorrect.");
					}

					var argsW = args.ToList();
					for (int i = 0; i <= lastRunSeq; i++) {
						LNode arg = argsW[i];
						if (!arg.IsLiteral) {
							if (arg.CallsMin(__runSequence, 1)) {
								combinedSequence.AddRange(arg.Args.WithoutLast(1));
								argsW[i] = arg = arg.Args.Last;
							}
							if (i < lastRunSeq) {
								// Create a temporary variable to hold this argument
								LNode tmpVarName, tmpVarDecl = TempVarDecl(arg, out tmpVarName);
								combinedSequence.Add(tmpVarDecl);
								argsW[i] = tmpVarName;
							}
						}
					}

					expr = expr.WithArgs(LNode.List(argsW));
				}

				return Pair.Create(combinedSequence, expr);
			}

			LNode ConvertVarDeclToRunSequence(VList<LNode> attrs, LNode varType, LNode varName, LNode initValue)
			{
				initValue = BubbleUpBlocks(initValue);
				varType ??= F.Missing;
				LNode @ref;
				attrs = attrs.WithoutNodeNamed(S.Ref, out @ref);
				matchCode(initValue)
				{
					case #runSequence($(...stmts), $resultValue):
						var newVarDecl = quote { [$(...attrs)] $varType $varName = $resultValue; };
						return initValue.WithArgs(stmts.Add(newVarDecl).Add(varName));
								
					default: // usual case
						var newVarDecl = quote { [$(...attrs)] $varType $varName = $initValue; };
						return quote( #runSequence($newVarDecl, $varName) );
				}
			}

			static bool IsQuickBindLhs(LNode value)
			{
				if (!value.IsId)
					return true;
				return char.IsUpper(value.Name.Name.TryGet(0, '\0'));
 			}
		}
	}
}
