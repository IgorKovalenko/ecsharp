using System;
using System.Collections.Generic;
using Loyc.Runtime;
using Loyc.Utilities;
using System.Collections;
using System.Text;
using Loyc.CompilerCore.Expressions;
using Loyc.Compatibility.Linq;

namespace Loyc.CompilerCore.Onep
{

	/// <summary>
	/// An One Nonterminal Expression Parser (ONEP) implementation by David Piepgrass.
	/// </summary><remarks>
	/// Please see Doc/onep.html for information about this parser, and see 
	/// <see cref="IOneParser">IOneParser</see> for information about the interface.
	/// </remarks>
	class BasicOneParser<Expr,Token> : IOneParser<Expr,Token>
		where Token : ITokenValue
	{
		public BasicOneParser() : this(null) { }
		public BasicOneParser(IEnumerable<IOneOperator<Expr,Token>> ops)
		{
			if (ops != null) 
				AddRange(ops);
			_outMatch.Parts = new OneOperatorMatchPart<Expr, Token>[1];
		}
		public void Add(IOneOperator<Expr,Token> op) 
			{ _ops.Add(op); _lutBuilt = false; }
		public void AddRange(IEnumerable<IOneOperator<Expr,Token>> ops)
			{ _ops.AddRange(ops); _lutBuilt = false; }
		public void Clear() 
			{ _ops.Clear(); ClearLUTs(); }
		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() 
			{ return GetEnumerator(); }
		public IEnumerator<IOneOperator<Expr,Token>> GetEnumerator() 
			{ return _ops.GetEnumerator(); }
		public IEnumerable<IOneOperator<Expr, Token>> Operators 
			{ get { return _ops; } }
		public int OperatorCount 
			{ get { return _ops.Count; } }

		protected int _startPosition;
		protected int _inputPosition;
		protected int _inputLength = 0;
		protected static readonly OneOperatorPart<Token> _EOF =
			new OneOperatorPart<Token>(new Symbol("IOneParser.EOF"), null);
		protected List<IOneOperator<Expr,Token>> _ops = new List<IOneOperator<Expr,Token>>();
		protected bool _lutBuilt = false;
		protected bool _verbose = true;
		public bool Verbose { get { return _verbose; } set { _verbose = value; } }
		
		/// <summary>Source of tokens derived from _originalSource, or null if
		/// tokens didn't have to be subdivided. If this is nonnull then it is 
		/// the active source of tokens used by LA(), otherwise _originalSource is 
		/// the active source.</summary>
		protected BasicDividerSource<Token> _dividerSource;
		/// <summary>Source of tokens that was passed to Parse()</summary>
		protected IParserSource<Token> _originalSource;

		// Tables to quickly look up ops starting with a certain letter 
		// (int(op.Tok[0].Text[0]) & 0x3F) or int(LA.Text[0]) & 0x3F
		// or of a certain token type. I use a linked list because the lists
		// are expected to be very short (or empty) most of the time, so
		// this is more memory-efficient & faster than using List<> objects.
		protected OpLL[] _textLut1 = new OpLL[32];
		protected OpLL[] _typeLut1   = new OpLL[32];
		protected OpLL[] _textLut2 = new OpLL[32];
		protected OpLL[] _typeLut2   = new OpLL[32];
		protected class OpLL {
			public OpLL(IOneOperator<Expr,Token> op, OpLL next, int matchIndex) 
			{
				Op = op; 
				Next = next; 
				Parts = op.Parts; 
				MatchPart = Parts[matchIndex]; 
			}
			public IOneOperator<Expr,Token> Op;
			public OpLL Next;
			public OneOperatorPart<Token>[] Parts;
			public OneOperatorPart<Token> MatchPart;
			public bool Match(ITokenValue token)
			{
				// TODO: If MatchPart.MatchesExpr, then this part should match the
				// "first set", i.e. the first part of any operator. Either that or it should
				// always match, unconditionally; I'm not sure yet.
				if (MatchPart.MatchesExpr)
					System.Diagnostics.Debugger.Break();
				return MatchPart.Match(token);
			}
		}

		protected void ClearLUTs()
		{
			// Clear lookup tables
			Array.Clear(_textLut1, 0, _textLut1.Length);
			Array.Clear(_textLut2, 0, _textLut2.Length);
			Array.Clear(_typeLut1, 0, _typeLut1.Length);
			Array.Clear(_typeLut2, 0, _typeLut2.Length);
			_lutBuilt = false;
		}
		protected void AutoBuildLUTs()
		{
			if (_lutBuilt)
				return;
			ClearLUTs();
			
			uint textFirstSet = 0, typeFirstSet = 0;
			
			foreach(IOneOperator<Expr,Token> op in _ops) {
				if (op.Parts.Length == 0 || (op.Parts.Length == 1 && op.Parts[0].MatchesExpr))
					continue; // This operator is invalid (too short); skip it
				OneOperatorPart<Token> p1 = op.Parts[0], p2;
				if (!p1.MatchesExpr) {
					if (!string.IsNullOrEmpty(p1.Text)) {
						int i = p1.Text[0] & 0x1F;
						_textLut1[i] = new OpLL(op, _textLut1[i], 0);
						textFirstSet |= (uint)1 << i;
					} else {
						int i = p1.Type.Id & 0x1F;
						_typeLut1[i] = new OpLL(op, _typeLut1[i], 0);
						typeFirstSet |= (uint)1 << i;
					}
				} else if (!(p2 = op.Parts[1]).MatchesExpr) {
					// Note: the case where p2.MatchesExpr is true is handled after
					// the first sets are determined.
					if (!string.IsNullOrEmpty(p2.Text)) {
						int i = p2.Text[0] & 0x1F;
						_textLut2[i] = new OpLL(op, _textLut2[i], 1);
					} else {
						int i = p2.Type.Id & 0x1F;
						_typeLut2[i] = new OpLL(op, _typeLut2[i], 1);
					}
				}
			}
			foreach(IOneOperator<Expr,Token> op in _ops) {
				if (op.Parts.Length >= 2 && op.Parts[0].MatchesExpr && op.Parts[1].MatchesExpr) {
					// This operator begins with two expressions; to detect the second
					// expression with lookahead, add it to all array entries in the 
					// binary lookup table that correspond to the first set of operators
					// in the unary lookup table.
					for (int i = 0; i < 32; i++) {
						if ((textFirstSet & (1 << i)) != 0)
							_textLut2[i] = new OpLL(op, _textLut2[i], 1);
						if ((typeFirstSet & (1 << i)) != 0)
							_typeLut2[i] = new OpLL(op, _typeLut2[i], 1);
					}
				}
			}
			_lutBuilt = true;
		}

		protected bool IsTooLong(OpLL op)
		{
			return op.Parts.Length > _inputLength - _inputPosition;
		}

		protected void MatchText1(ITokenValue la, ref List<OpLL> list)
		{
			string text = la.Text;
			if (string.IsNullOrEmpty(text))
				return;
			int text_i = text[0] & 0x1F;
			MatchLA(la, _textLut1[text_i], ref list);
		}
		protected void MatchType1(ITokenValue la, ref List<OpLL> list)
		{
			Symbol type = la.Type;
			if (type.IsNull)
				return;
			int type_i = type.Id & 0x1F;
			MatchLA(la, _typeLut1[type_i], ref list);
		}
		protected void MatchText2(ITokenValue la, ref List<OpLL> list)
		{
			string text = la.Text;
			if (string.IsNullOrEmpty(text))
				return;
			int text_i = text[0] & 0x1F;
			MatchLA(la, _textLut2[text_i], ref list);
		}
		protected void MatchType2(ITokenValue la, ref List<OpLL> list)
		{
			Symbol type = la.Type;
			if (type.IsNull)
				return;
			int type_i = type.Id & 0x1F;
			MatchLA(la, _typeLut2[type_i], ref list);
		}
		void MatchLA(ITokenValue la, OpLL op, ref List<OpLL> list)
		{
			for (; op != null; op = op.Next) {
				if (op.Match(la)) {
					if (list == null)
						list = new List<OpLL>();
					list.Add(op);
				}
			}
		}

		protected TokenValue EofToken = new TokenValue(Tokens.Null, null);

		public Expr Parse(IParserSource<Token> source, ref int position, bool untilEnd, IOperatorDivider divider)
		{
			_originalSource = source;
			_inputPosition = position;
			_inputLength = source.Length;
			if (divider != null && BasicDividerSource<Token>.MightNeedDivision
			    (source, position, _inputLength - position, divider)) {
				// Create _dividerSource to use as our active token source.
				_dividerSource = new BasicDividerSource<Token>(divider);
				_dividerSource.Process(source, position, _inputLength - position);
				// In the _dividerSource, position zero corresponds to the 
				// original input position.
				_inputPosition = 0;
				_inputLength = _dividerSource.Length;
			}
			_startPosition = _inputPosition;

			if (_verbose) SpitTokenList();

			// Look at the first token from the input TODO...
			ITokenValue eof = null;
			if (untilEnd) eof = EofToken;
			Expr expr;
			bool success = SubParse(999, eof, out expr);
			
			// At the end:
			if (_dividerSource != null)
				position = _dividerSource.IndexInOriginalSource(_inputPosition);
			else
				position = _inputPosition;
			return expr;
		}

		protected bool SubParse(int maxPrec, ITokenValue followToken, out Expr expr)
		{
			if (_verbose) PushSpit(maxPrec, followToken);

			try {
				// Let's examine LA(0).
				ITokenValue LA0 = LA(0);
				if (_verbose) { SpitStack(); SpitLA(LA0); }

				List<OpLL> inMatches = null;
				MatchText1(LA0, ref inMatches);
				if (inMatches != null) {
					Debug.Assert(inMatches.Count > 0);
					if (TryMatches(maxPrec, inMatches, 1, out expr))
						return true;
				}
				MatchType1(LA0, ref inMatches);
				if (inMatches != null && inMatches.Count > 0) {
					if (TryMatches(maxPrec, inMatches, 1, out expr))
						return true;
				}

				// Now examine LA(0) again
			} finally {
				if (_verbose) PopSpit();
			}
			expr = default(Expr);
			return false;
		}
		/// <summary>List of completed matches. Maybe it should be a local variable 
		/// in TryMatches, but it's here as an optimization (so it doesn't have
		/// to be reallocated on every call)</summary>
		public List<OneOperatorMatch<Expr, Token>> _outMatches = new List<OneOperatorMatch<Expr, Token>>();
		/// <summary>The current, incomplete, match. Maybe it should be a local 
		/// variable in TryMatches, but it's here as an optimization (so it doesn't 
		/// have to be reallocated on every call)</summary>
		public MyOneOperatorMatch<Expr, Token> _outMatch = new MyOneOperatorMatch<Expr, Token>();
		/// <summary>List of error messages from operators. Maybe it should be a local 
		/// variable in Disambiguate(), but it's here as an optimization (so it doesn't 
		/// have to be reallocated on every call)</summary>
		public MessageList _ambigMsgs = new MessageList();

		protected class MyOneOperatorMatch<Expr, Token> : OneOperatorMatch<Expr, Token>
			where Token : ITokenValue
		{
			public int EndInputPosition;
		}

		protected bool TryMatches(int maxPrec, List<OpLL> inMatches, int prematched, out Expr expr)
		{
			if (_verbose && inMatches.Count > 1) SpitMatchList(inMatches);
			int count = inMatches.Count;
			if (count > 1)
				_outMatches.Clear();

			for (int i = 0; i < inMatches.Count; i++)
			{
				OpLL match = inMatches[i];
				
				// Initialize OneOperatorMatch result structure
				_outMatch.IsAcceptable = false;
				_outMatch.Operator = inMatches[i].Op;
				if (_outMatch.Parts.Length != match.Parts.Length)
					_outMatch.Parts = new OneOperatorMatchPart<Expr, Token>[match.Parts.Length];

				// Match against the rest of the operator
				if (!MatchTheRest(maxPrec, match, prematched))
					continue;

				// Success.
				if (inMatches.Count == 1) {
					expr = match.Op.Generate(_outMatch);
					return true;
				} else
					_outMatches.Add(_outMatch);
			}
			if (_outMatches.Count == 1) {
				expr = _outMatches[0].Operator.Generate(_outMatches[0]);
				return true;
			}
			if (_outMatches.Count == 0) {
				expr = default(Expr);
				return false;
			}
			// Two or more
			OneOperatorMatch<Expr, Token> m = Disambiguate(_outMatches);
			if (m == null) {
				expr = default(Expr);
				return false;
			} else {
				expr = m.Operator.Generate(m);
				return true;
			}
		}

		protected virtual OneOperatorMatch<Expr, Token> DisambiguateTwo(List<OneOperatorMatch<Expr, Token>> matches)
		{
			// The most common, simple case
			int prio = ComparePriority(matches[0].Operator, matches[1].Operator);
			if (prio > 0)
				return matches[0];
			else if (prio < 0)
				return matches[1];
			bool a0 = CheckAcceptable(matches[0]);
			bool a1 = CheckAcceptable(matches[1]);
			int count = (a0 ? 1 : 0) + (a1 ? 1 : 0);
			if (count == 1)
				return matches[a1 ? 1 : 0];

			WriteDisambiguationErrors(matches, count);
			return null;
		}

		protected virtual void WriteDisambiguationErrors(List<OneOperatorMatch<Expr, Token>> matches, int countAccepted)
		{
			Debug.Assert(matches.Count == 2);
			// LINQ query:
			//   from m in matches
			//   select "'" + m.Operator.Name + "'"
			IEnumerable<string> list =
				Enumerable.Select<OneOperatorMatch<Expr, Token>, string>(matches,
					delegate(OneOperatorMatch<Expr, Token> m) 
						{ return "'" + m.Operator.Name + "'"; });
			WriteErrorEN("Failed to resolve ambiguity between {0} operators: {1}.",
				matches.Count, Strings.Join(", ", list));
			if (countAccepted < matches.Count) {
				list = Enumerable.Select<OneOperatorMatch<Expr, Token>, string>(
					Enumerable.Where(matches,
						delegate(OneOperatorMatch<Expr, Token> m) 
							{ return !m.IsAcceptable; }),
					delegate(OneOperatorMatch<Expr, Token> m) 
						{ return "'" + m.Operator.Name + "'"; });
				WriteErrorEN("{0} possibilities were rejected: {1}",
					matches.Count - countAccepted, Strings.Join(", ", list));
			}
			foreach (MessageList.Message info in _ambigMsgs.MsgList) {
				string msg = Translate.Do(info.Resource, info.Lang, info.Msg, info.Args);
				WriteErrorEN("While interpreting '{0}': {1}", info.Match.Operator.Name, msg);
			}
		}

		protected virtual OneOperatorMatch<Expr,Token> Disambiguate(List<OneOperatorMatch<Expr,Token>> matches)
		{
			// Two or more matches have to be disambiguated
			Debug.Assert(matches.Count >= 2 && _ambigMsgs.MsgList.Count == 0);

			try {
				if (matches.Count == 2) {
					return DisambiguateTwo(matches);
				} else {
					// First check acceptability.
					int count;
					int lastAcceptable = -1;
					count = matches.Count; // we decrease this each time a match is disqualified
					for(int i = 0; i < matches.Count; i++){
						if (!CheckAcceptable(matches[i]))
							count--;
						else
							lastAcceptable = i;
					}

					if (count > 1) {
						// Next, narrow down the list by eliminating operators where something 
						// else has a higher priority.
						bool[] hasHigher = new bool[matches.Count];
						for(int i = 0; i < matches.Count; i++) {
							if (!matches[i].IsAcceptable)
								continue;
							for (int j = i + 1; j < matches.Count; j++) {
								if (!matches[j].IsAcceptable)
									continue;
								int cmp = ComparePriority(matches[i].Operator, matches[j].Operator);
								if (cmp < 0) {
									hasHigher[i] = true;
									count--;
								}
							}
							if (!hasHigher[i])
								lastAcceptable = i;
						}
						if (count == 1)
							// Success!
							return matches[lastAcceptable];
						//Strings.Join(", ", matches)
					}
					
					// Failure.
					WriteDisambiguationErrors(matches, count);
					return null;
				}
			} finally {
				_ambigMsgs.MsgList.Clear();
			}
		}
		protected static readonly string OpCallInternalErr = "OpCallInternalErr\0Internal error: calling '{0}' in operator '{1}' caused an exception: {2}";

		protected int ComparePriority(IOneOperator<Expr, Token> a, IOneOperator<Expr, Token> b)
		{
			int pa = 0, pb = 0;
			try {
				pa = a.ComparePriority(b);
			} catch (Exception e) {
				WriteErrorEN(OpCallInternalErr, "ComparePriority", a.Name, e.ToString());
			}
			try {
				pb = b.ComparePriority(a);
			} catch (Exception e) {
				WriteErrorEN(OpCallInternalErr, "ComparePriority", a.Name, e.ToString());
			}
			return pa - pb; // Return >0 if pa>pb
		}
		protected bool CheckAcceptable(OneOperatorMatch<Expr,Token> match)
		{
			try {
				_ambigMsgs.CurMatch = match;
				return (match.IsAcceptable = match.Operator.IsAcceptable(match, _ambigMsgs));
			} catch(Exception e) {
				WriteErrorEN(OpCallInternalErr, "IsAcceptable", match.Operator.Name, e.ToString());
				return false;
			}
		}
		
		protected bool MatchTheRest(int maxPrec, OpLL match, int prematched)
		{
			BeginGuess();
			try {
				int i = prematched;
				for(;;) {
					if (_verbose) SpitPartialMatchStatus(_outMatch.Parts, match.Parts, i);
					if (i >= match.Parts.Length)
						break;
					if (!MatchOnePart(match.Parts[i], i == match.Parts.Length-1))
						return false;
				}
				return true;
			} finally {
				_outMatch.EndInputPosition = _inputPosition;
				EndGuess();
			}
		}

		private bool MatchOnePart(OneOperatorPart<Token> part, bool isFinal)
		{
			if (part.MatchesExpr)
				SubParse(
		}

		private void SpitPartialMatchStatus(OneOperatorMatchPart<Expr, Token>[] matched, OneOperatorPart<Token>[] unmatched, int pos)
		{
			for (int i = 0; i < pos; i++) {
				if (matched[i].MatchedExpr)
					SpitExpr(matched[i].Expr);
				else
					Console.Write("'" + matched[i].Token.Text + "'");
				if(i + 1 == pos)
					Console.Write('.');
				Console.Write(' ');
			}
			SpitParts(unmatched, pos);
		}

		protected Stack<int> _savedPositions = new Stack<int>();
		public void BeginGuess()
		{
			_savedPositions.Push(_inputPosition);
		}
		public void EndGuess()
		{
			_inputPosition = _savedPositions.Pop();
		}
		protected void WriteErrorEN(string msg, params object[] args)
		{
			Console.WriteLine(msg, args);
		}

		public class MessageList : IOneMessageSink 
		{
			public class Message 
			{
				public Message(OneOperatorMatch<Expr, Token> Match, Symbol Category, Symbol Resource, string Lang, string Msg, object[] Args)
				{
					this.Match = Match;
					this.Category = Category;
					this.Resource = Resource;
					this.Lang = Lang;
					this.Msg = Msg;
					this.Args = Args;
				}
				public OneOperatorMatch<Expr, Token> Match;
				public Symbol Category;
				public Symbol Resource;
				public string Lang;
				public string Msg;
				public object[] Args;
			}
			public OneOperatorMatch<Expr, Token> CurMatch;
			public List<Message> MsgList = new List<Message>();
			
			public void Write(Symbol category, string lang, string msg, params object[] args)
			{
				MsgList.Add(new Message(CurMatch, category, Symbol.Null, lang, msg, args));
			}
			public void Write(Symbol category, Symbol resource, params object[] args)
			{
				MsgList.Add(new Message(CurMatch, category, resource, null, null, args));
			}
		}

		protected ITokenValue LA(int p)
		{
			if (_dividerSource != null)
				return _dividerSource[_inputPosition + p];
			else
				return _originalSource[_inputPosition + p];
		}

		#region Verbose mode progress spitting
		protected Stack<Pair<int, ITokenValue>> _spitStack;

		protected virtual void SpitTokenList()
		{
			SpitStack();
			for (int i = 0; i < _inputLength; i++)
				Console.Write(LA(i - _startPosition).Text + ' ');
			Console.Write("// Types: ");
			for (int i = 0; i < _inputLength; i++)
				Console.Write(LA(i - _startPosition).Type.SafeName + ' ');
			Console.WriteLine();
		}
		protected virtual void SpitStack() { SpitStack("| "); }
		protected virtual void SpitStack(string prompt)
		{
			if (_spitStack == null)
				return;
			StringBuilder s = new StringBuilder(10);
			foreach (Pair<int, ITokenValue> p in _spitStack) {
				s.Append('|');
				s.Append(p.A.ToString());
				if (p.B != null) {
					if (p.B.Text != null) {
						s.Append(' ');
						s.Append(p.B.Text);
					} else
						s.Append(p.B.Type.ToString());
				}
			}
			s.Append(prompt);
			Console.Write(s.ToString());
		}
		protected virtual void PushSpit(int maxPrec, ITokenValue followToken)
		{
			if (_spitStack == null)
				_spitStack = new Stack<Pair<int, ITokenValue>>();
			_spitStack.Push(new Pair<int, ITokenValue>(maxPrec, followToken));
		}
		protected virtual void PopSpit()
		{
			if (_spitStack.Count != 0) _spitStack.Pop();
		}
		protected virtual void SpitLA(ITokenValue la)
		{
			if (la == EofToken)
				Console.WriteLine("(?$)");
			else if (la == null)
				Console.WriteLine("(? null)");
			else
				Console.WriteLine("(?'{0}'{1})", la.Text, la.Type.ToString());
		}

		private void SpitExpr(object any_e)
		{
			LoycExpr e = any_e as LoycExpr;

			if (e == null) {
				Console.Write("{{{0}}}", any_e);
			} else {
				Console.Write("e{");
				OneOperatorPart<IToken>[] ps = e.Operator.Parts;
				int child_i = 0;
				bool spacingEl = false;
				for (int i = 0; i < ps.Length; i++) {
					if (ps[i].MatchesExpr) {
						Debug.Assert(e.ChildCount > child_i);
						if (i == 0)
							SpitSubExpr(e.FirstExpr, ref spacingEl);
						else if (i == 1)
							SpitSubExpr(e.SecondExpr, ref spacingEl);
						else
							SpitSubExpr(e.ExprChildren[i], ref spacingEl);
					} else if (!string.IsNullOrEmpty(ps[i].Text)) {
						string text = ps[i].Text;
						if (spacingEl && char.IsLetterOrDigit(text[0]))
							Console.Write(' ');
						Console.Write(text);
						spacingEl = char.IsLetterOrDigit(text[text.Length - 1]);
					} else {
						if (spacingEl)
							Console.Write(' ');
						Console.Write(ps[i].Type.SafeName);
						spacingEl = true;
					}
				}
				Console.Write('}');
			}
		}
		private void SpitSubExpr(LoycExpr e, ref bool spacingEl)
		{
			if (spacingEl)
				Console.Write(' ');
			if (e is IdExpr || e is NumericExpr)
				Console.Write(e.Prototype.Text);
			else
				Console.Write('e');
			spacingEl = true;
		}

		protected virtual void SpitMatchList(List<BasicOneParser<Expr, Token>.OpLL> matches)
		{
			SpitStack("> Matches: ");
			foreach (OpLL op in matches) {
				SpitParts(op.Op.Parts, 0);
				Console.Write("; ");
			}
		}

		protected virtual void SpitParts(OneOperatorPart<Token>[] parts, int i)
		{
			for (; i < parts.Length; i++) {
				if (parts[i].MatchesExpr)
					Console.Write("e{0} ", parts[i].Prec);
				else if (parts[i].Text != null) {
					Console.Write("'{0}'", parts[i].Text);
					if (parts[i].Type != Tokens.Null)
						Console.Write("({0})", parts[i].Type.SafeName);
				} else {
					Console.Write(parts[i].Type.SafeName);
				}
			}
		}
		#endregion
		/*public Expr Parse(IParserSource<Token> source, int startPosition)
		{
			_source = source;
			_inputLength = source.Length;
			SubParse(startPosition, 100, _EOF);
		}

		public struct ResultExpr {
			public ResultExpr(Expr expr, int length) { 
				Expr = expr; 
				Length = length;
				Debug.Assert(length > 0);
			}
			public Expr Expr;
			public int Length;
			public static readonly ResultExpr Null = new ResultExpr();
			public bool IsNull { get { return Expr == null; } }
		}

		IEnumerator<ResultExpr> SubParse(int start, int maxPrec, OneOperatorPart<Token> follows)
		{
			// Find out what operator(s) match the first token (LA0) by text. For each 
			// matching possibility, follow it through to find out what expression 
			// matches (if any).
			Token LA0 = LA(start, 0);
			List<OpLL> matches = MatchText1(LA0);
			bool yielded = false;
			if (matches != null && matches.Count > 0)
				foreach (ResultExpr e in SubParse2(start, matches, maxPrec, follows)) {
					yield return e;
					yielded = true;
				}
			matches = MatchType1(LA0);
			
			// Emit priority divider: text matches have higher priority than type matches
			if (yielded)
				yield return ResultExpr.Null;
			
			// Repeat, except find out what operator(s) match LA0 by type this time.
			if (matches != null && matches.Count > 0)
				foreach (ResultExpr e in SubParse2(start, matches, maxPrec, follows))
					yield return e;
		}
		
		IEnumerator<ResultExpr> SubParse2(int start, List<OpLL> matches, int maxPrec, OneOperatorPart<Token> follows)
		{
			Debug.Assert(follows == null || !follows.MatchesExpr);
			// Each of the operators in 'matches' has already matched the first item.
			// Try to match the other items. Each possibility has equal priority, so 
			// interleave the outputs so that all high-priority possibilities from all
			// operators come before all lower-priority possibilities. In order to do
			// this, get all the result lists and then 
			List<IEnumerator<ResultExpr>> results = new List<IEnumerator<Expr>>(matches.Count);
			foreach (OpLL m in matches)
				results.Add(MatchRemainder(start, m, maxPrec, follows));
			
			bool areAnyLeft, yielded, needDivider = false;
			do {
				areAnyLeft = yielded = false;
				for(int i=0; i<results.Count; i++) {
					if (results[i] != null) {
						for(;;) {
							if (!results[i].MoveNext()) {
								// This output has come to an end
								results[i] = null;
								break;
							}
							areAnyLeft = true;
							ResultExpr result = results[i].Current;
							if (result.IsNull)
								// Current priority level (in results[i]) is over
								break;
							// MatchRemainder() should only return results with the 
							// proper following value
							Debug.Assert(follows == null ||
								(follows == _EOF && result.Length == _length - start) ||
								follows.Match(start + result.Length));
							if (needDivider) {
								// Emit priority divider
								needDivider = false;
								yield return ResultExpr.Null;
							}
							yielded = true;
							yield return result;
						}
					}
				}
				if (yielded)
					// Request priority divider
					needDivider = true;
			} while(areAnyLeft);
		}

		IEnumerator<ResultExpr> MatchRemainder(int start, int firstPart, OneOperatorMatch<Expr,Token> outmatch, OpLL inmatch, int maxPrec, OneOperatorPart<Token> follows)
		{
			Oops, what if the match branches? it will not be enough to have one OneOperatorMatch!
			// For the match possibility 'match', the previous part has already been matched:
			Debug.Assert(match.Parts[firstPart-1].MatchesExpr || match.Parts[firstPart-1].Match(LA(start, -1));
			
			// Follow through to the end of the operator
			IEnumerator<ResultExpr> results = null;
			int offs = 0;
			for(int i = 1; i <match.Parts.Length; i++) {
				OneOperatorPart<Token> p = match.Parts[i];
				if (p.MatchesExpr) {
					// Get precedence of subexpression, adjusting for left associativity
					int subPrec = ((p.Prec - 1) & ~1) + 1;
					// Determine follow token, if any
					OneOperatorPart<Token> subFollows = null;
					if (i+1 == match.Parts.Length)
						subFollows = follows;
					else if (!match.Parts[i+1].MatchesExpr)
						subFollows = match.Parts[i+1];
					SubParse(start, subPrec,  
					results = MatchRemainder2(start+offs, match, i, Math.Min(maxPrec, subPrec));
				} else {
					if (!match.Parts[i].Match(LA(start, offs)))
						return; // Matching failed.
				}
				offs++;
			}
			if (results == null) {
				// The operator consisted entirely of terminals. Create result for it.
				
				// TODO
				//new ResultExpr (CreateExpr(), offs-1)
				
				// try to continue parsing to form a more complex expression.
				return SubParse5(TODO);
			}
			// "reduce" it
			foreach (ResultExpr result in results)
				// try to continue parsing to form a more complex expression.
				return SubParse5(TODO);
		}
		Token LA(int start, int offs)
		{
			return _source[start + offs];
		}
		*/
		// When there is more than one match, use IASTNode's extended attributes to create a linked list
		/*public Expr Parse(List<Token> tok)
		{
			Expr result = DoLevel(tok, 0);
			if (result.Get("AltONEP") as Expr) {
				ReportAmbigList(result); // TODO
			}
		}
		
		public Expr DoLevel(List<Token> tok, int startAt)
		{
			if (startAt >= tok.Count)
				return null;
			Token LA = tok[startAt]; // Lookahead token
			Expr expr = null;        // Result
			
			// Try to match operators using the LA token as a hint
			// 1. Try SPECIFIC possibilities in _quickLL (match Text)
			// 2. Then try GENERAL possibilities in _ops (match TT only)
			if (!string.IsNullOrEmpty(LA.Text)) {
				OpLL list = _textLU[(int)LA.Text[0] & 0x3F];
				expr = TryList(list, tok, startAt);
			}
			if (expr == null) {
				OpLL list = _TTLU[(int)LA.TT & 0xF];
				expr = Merge(expr, TryList(list, tok, startAt));
			}

			return expr;
		}
		void TryList(OpLL list, List<Token> tok, int startAt)
		{
			while (list != null) {
				if (list.op.TT == tok.TT && (list.op.Text == null || list.op.Text == tok.Text)) {
					// Token matches!
					Merge(expr, TryMatchButSkipFirst(list.op, tok, startAt));
				}
				list = list.next;
			}
		}
		static Expr Merge(Expr oldExp, Expr newExp) 
		{
			if (newExp == null)
				return oldExp;
			if (oldExp == null)
				return newExp;
			else {
				newExp.Set("AltONEP", oldExp);
				return newExp;
			}
		}*/
	}

}
