/*
	Oh what fun, I'll finally get to compile a grammar using LLLPG!
	It's taken more than a year to get to this point, how exciting!!!

	OK, the goal: WRITE THE GRAMMAR OF LES IN LES.
*/
import macros LeMP.Prelude.Les;
import System;
import System.Collections.Generic;
import System.Linq;
import System.Text;
import Loyc;
import Loyc.Collections;
import Loyc.Syntax;
import Loyc.Syntax.Lexing;

namespace Loyc.Syntax.Les
:{
	using TT = TokenType;
	using S = CodeSymbols;
	using P = LesPrecedence;

	// 0162=Unreachable code detected; 0642=Possibly mistaken empty statement
	#rawText("#pragma warning disable 162, 642");

	public partial class LesParser
	{
		[FullLLk, LL(1), AddCsLineDirectives(@false)]
		LLLPG(parser(laType(TT), matchType(int), terminalType(Token), allowSwitch(@true)));
		
		alias("@" = TT.At);
		alias(":" = TT.Colon);
		alias(";" = TT.Semicolon);
		alias("," = TT.Comma);
		alias("!" = TT.Not);
		//alias(" (" = TT.SpaceLParen);
		alias("(" = TT.LParen);
		alias(")" = TT.RParen);
		alias("[" = TT.LBrack);
		alias("]" = TT.RBrack);
		alias("{" = TT.LBrace);
		alias("}" = TT.RBrace);

		public rule StmtList()::RVList!LNode @[
			{endMarker := TT.Semicolon;}
			result:ExprList(ref endMarker)
		];
		public fn ExprList(list::RVList!LNode = default(RVList!LNode))::RVList!LNode {
			endMarker := default(TT);
			return (ExprList(ref endMarker, list));
		};

		// A sequence of expressions separated by commas OR semicolons.
		// The `ref endMarker` parameter tells the caller if semicolons were used.
		public rule ExprList(ref endMarker::TokenType, list::RVList!LNode = default(RVList!LNode))::RVList!LNode @[
			// `(/X)` is the same as `[X]?` except that in the first version, X is 
			// the default branch, which simplifies the output code in this case.
			(/ e:ExprStart)
			[	end:(","|";")
				{list.Add(e ?? MissingExpr());}
				{CheckEndMarker(ref endMarker, ref end);}
				({$e = null;} / e:ExprStart)
			]*
			{if ($e != null || end.Type() == TT.Comma) list.Add(e ?? MissingExpr());}
			{return list;}
		];
		public rule ExprListLazy(endMarker::Holder!TokenType)::IEnumerable!LNode @[
			(/ e:ExprStart)
			[	end:(","|";")
				{#rawText("yield"); return e ?? MissingExpr();}
				{CheckEndMarker(ref endMarker.Value, ref end);}
				({$e = null;} / e:ExprStart)
			]*
			{if ($e != null || end.Type() == TT.Comma) {#rawText("yield"); return e ?? MissingExpr();}}
		];
		fn CheckEndMarker(ref endMarker::TokenType, ref end::Token)
		{
			if (endMarker != end.Type()) {
				if (endMarker == default(TT)) {
					endMarker = end.Type();
				} else {
					Error(-1, "Unexpected separator: {0} should be {1}",
						ToString(end.TypeInt), ToString(endMarker->int));
				};
			};
		};

		protected rule ExprStart()::LNode @[
			// Use a gate to simplify the decision about whether to call this rule
			[	// [Attributes]
				t:"[" attrs:ExprList "]"
			]?
			e:Expr(StartStmt)
			{
				if (t.TypeInt != 0) { e = e.WithRange(t.StartIndex, e.Range.EndIndex); };
				return e.PlusAttrs(attrs);
			}
		];

		// Types of expressions:
		// - atoms (parenthesized), {braced}, ids, literals
		// - ++prefix_operators
		// - infix + operators
		// - suffix_operators++
		// - juxtaposition expressions
		// - Special primary expressions:
		//   method_calls(with arguments), indexers[with indexes], generic!arguments
		token Expr(context::Precedence)::LNode @[
			{prec::Precedence;}
			e:PrefixExpr(context)
			greedy
			[	// Infix operator
				&{[Local] context.CanParse(prec=InfixPrecedenceOf(LT($LI)))}
				(t:(TT.NormalOp|TT.BQString|TT.Dot|TT.Assignment) | &{[Local] LA($LI+1) != TT.Indent->int} t:":")
				rhs:=Expr(prec)
				{e = F.Call(t.Value -> Symbol, e, rhs, e.Range.StartIndex, rhs.Range.EndIndex).SetBaseStyle(NodeStyle.Operator);}
			/	// Method_calls(with arguments), indexers[with indexes], generic!arguments
				&{[Local] context.CanParse(P.Primary)}
				e=FinishPrimaryExpr(e)
			/	// Suffix operator
				&{[Local] context.CanParse(SuffixPrecedenceOf(LT($LI)))}
				t:TT.PreOrSufOp
				{e = F.Call(ToSuffixOpName(t.Value -> Symbol), e, e.Range.StartIndex, t.EndIndex).SetBaseStyle(NodeStyle.Operator);}
			/	// Juxtaposition
				&{[Local] context.CanParse(P.Juxtaposition)}
				{hasArgsAlready := e.BaseStyle == NodeStyle.PrefixNotation;}
				{args := hasArgsAlready ? e.Args : RVList!LNode.Empty;}
				greedy( args+=Atom(true) )+
				{
					if (hasArgsAlready) {
						e = e.WithArgs(args).WithRange(e.Range.StartIndex, args.Last.Range.EndIndex);
					} else {
						e = F.Call(e, args, e.Range.StartIndex, args.Last.Range.EndIndex);
					};
				}
			]*
			{return e;}
		];

		// Helper rule that parses one of the syntactically special primary expressions
		private rule FinishPrimaryExpr(e::LNode)::LNode @[
			(	// call(function)
				"(" list:ExprList c:=")"
				{e = F.Call(e, list, e.Range.StartIndex, c.EndIndex).SetBaseStyle(NodeStyle.PrefixNotation);}
			|	// ! operator (generic #of)
				"!"
				{args := (new(RVList!LNode) { e }); endIndex::int;}
				(	"(" args=ExprList(args) c:=")"  {endIndex = c.EndIndex;}
				/	T:=Expr(P.Primary)              {args.Add(T); endIndex = T.Range.EndIndex;}
				)
				{e = F.Call(S.Of, args, e.Range.StartIndex, endIndex).SetBaseStyle(NodeStyle.Operator);}
			|	// Indexer / square brackets
				{args := (new(RVList!LNode) { e });}
				"[" args=ExprList(args) c:="]"
				{e = F.Call(S.Bracks, args, e.Range.StartIndex, c.EndIndex).SetBaseStyle(NodeStyle.Operator);}
			)
			{return e;}
		];

		private rule PrefixExpr(context::Precedence)::LNode @
			[	result:Atom
			|	// Prefix operator
				t:(TT.NormalOp|"!"|TT.BQString|TT.Dot|TT.Assignment|TT.PrefixOp|TT.PreOrSufOp) 
				e:Expr(PrefixPrecedenceOf(t))
				{$result = F.Call(t.Value -> Symbol, e, t.StartIndex, e.Range.EndIndex).SetBaseStyle(NodeStyle.Operator);}
			|	error
				{$result = MissingExpr(); Error(0, "Expected an expression here");}
			];

		// An Atom is:
		// - an (expression) in parenthesis or a tuple
		// - a literal or simple identifier
		//   - simple calls are also handled here, as a space optimization
		// - a token literal @[ ... ]
		// - a prefix operator followed by an Expr
		// - a { block } in braces
		private rule Atom(juxtaposition::bool = false)::LNode @[
			(	id:=TT.Id // identifier
				{$result = F.Id(id);}
			|	lit:=(TT.Number|TT.String|TT.OtherLit) // literal
				{$result = F.Literal(lit);}
			|	// @[Token literal]
				o:="@" "[" tree:TokenTree c:="]"
				{$result = F.Literal(tree, o.StartIndex, c.EndIndex);}
			|	// colon indent (outside spec. LesIndentTokenGenerator inserts ";" after Dedent, unless user adds ":")
				o:=":" TT.Indent list:=StmtList c:=TT.Dedent greedy[":"]? 
				{$result = F.Braces(list, o.StartIndex, c.EndIndex);}
			|	// {braces}
				o:="{" list:=StmtList c:="}" 
				{$result = F.Braces(list, o.StartIndex, c.EndIndex).SetBaseStyle(NodeStyle.Statement);}
			|	// (parens) - possibly a tuple
				{
					if (juxtaposition) {
						Error(0, "'(' is not permitted here. Did you forget a ';' (or ',') at the end of the previous expression?");
					};
					endMarker := default(TT);
				}
				o:="(" {hasAttrList := LA0->TT == TT.LBrack;}
				list:=ExprList(ref endMarker)
				c:=")" {
					if (endMarker == TT.Semicolon || list.Count != 1) {
						$result = F.Call(S.Tuple, list, o.StartIndex, c.EndIndex);
						if (endMarker == TT.Comma) {
							ErrorSink.Write(Severity.Error, list[0].Range.End, "Tuples require ';' as a separator.");
						};
					} else {
						$result = hasAttrList ? list[0] : F.InParens(list[0], o.StartIndex, c.EndIndex);
					};
				}
			|	error {Error(0, "Subexpression expected here");} _
				{$result = MissingExpr();}
			)
		];

		rule TokenTree::TokenTree @[
			{$result = `new` TokenTree(SourceFile);}
			nongreedy(
				open:=("("|"["|"{"|TT.Indent)
				TokenTree
				{$result.Add(open.WithValue($TokenTree));}
				result+=(")"|"]"|"}"|TT.Dedent)
			/	result+=_
			)*
		];
	};
};
