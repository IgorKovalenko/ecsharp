#ecs;
#importMacros(Loyc.LLPG);
using System(, .Text, .Linq, .Collections.Generic, .Diagnostics);
using Loyc;               // optional (for IMessageSink, Symbol, etc.)
using Loyc.Collections;   // optional (many handy interfaces & classes)
using Loyc.Syntax.Lexing; // For BaseLexer
using Loyc.Syntax;        // For BaseParser<Token> and LNode

namespace Loyc.Syntax.Les; // braces around the rest of the file are optional

using TT = TokenType; // Abbreviate TokenType as TT
using P = LesPrecedence;
using S = CodeSymbols;

public partial class Les3Lexer
{
	protected new object ParseIdValue(bool isFancy)
	{
		object result = base.ParseIdValue(isFancy);
		if (!isFancy) {
			if (result == @@true)
				return G.BoxedTrue;
			if (result == @@false)
				return G.BoxedFalse;
			if (result == @@null)
				return null;
		}
		return result;
	}

	[FullLLk, AddCsLineDirectives(false)]
	LLLPG (lexer) @{
	// `@{` invokes LLLPG in ANTLR-style syntax mode, but there are several 
	// differences; see http://ecsharp.net/lllpg/lllpg-in-antlr-style.html

	// Whitespace & comments -------------------------------------------------

	extern token Spaces : (' '|'\t')*;

	token Newline[bool ignoreIndent = false] returns [object result] :
		( '\r' '\n'? | '\n' )
		{return WhitespaceTag.Value;};
	private token SLComment returns [object result] :
		"//" (~('\r'|'\n'))* 
		{return WhitespaceTag.Value;};
	[LL(3)] private token MLComment returns [object result] :
		"/*" nongreedy(MLComment / Newline(true) / _)* "*/"
		{return WhitespaceTag.Value;};
		
	// Numbers ---------------------------------------------------------------
	
	private token Number returns [object result] :
		{ _isFloat = _isNegative = false; _typeSuffix = null; }
		('-' {_isNegative = true;})?
		(HexNumber / BinNumber / DecNumber)
		(_typeSuffix=NumberSuffix(ref _isFloat))?
		{return ParseNumberValue();};

	private DecDigits : '0'..'9'+ greedy('_' '0'..'9'+)* greedy('_')? ;
	[inline] HexDigit  : '0'..'9' | 'a'..'f' | 'A'..'F' ;
	private HexDigits : greedy(HexDigit)+ greedy('_' greedy(HexDigit)+)* greedy('_')? ;
	private DecNumber :
		{_numberBase=10;}
		( '.' DecDigits   {_isFloat=true;}
		| DecDigits     ( {_isFloat=true;} '.' DecDigits )?
		)
		greedy( {_isFloat=true;} ('e'|'E') ('+'|'-')? DecDigits )?
		;
	private HexNumber() :
		'0' ('x'|'X') {_numberBase=16;}
		greedy(HexDigits)?
		// Avoid ambiguity with 0x5.Equals(): a dot is not enough
		(	'.' ('0'..'9' => () / &( HexDigits ('p'|'P') ('+'|'-'|'0'..'9') ))
			{_isFloat=true;} HexDigits )?
		greedy( {_isFloat=true;} ('p'|'P') ('+'|'-')? DecDigits )?
		;
	private BinNumber :
		'0' ('b'|'B')     {_numberBase=2;}
		( '.' DecDigits   {_isFloat=true;}
		| DecDigits     ( {_isFloat=true;} '.' DecDigits )?
		)
		greedy( {_isFloat=true;} ('p'|'P') ('+'|'-')? DecDigits )?
		;
	
	[LL(3)] private NumberSuffix[ref bool isFloat] returns [Symbol result] 
		@init {var here = InputPosition;}
		: // known suffixes
		  ( ('f'|'F') {$result = _F; isFloat=true;}
		  | ('d'|'D') {$result = _D; isFloat=true;}
		  | ('m'|'M') {$result = _M; isFloat=true;}
		  | ('l'|'L') {$result = _L;} (('u'|'U') {$result = _UL;})?
		  | ('u'|'U') {$result = _U;} (('l'|'L') {$result = _UL;})?
		  ) (EndId =>)
		/ NormalId // unknown suffixes
		  { $result = IdToSymbol(CharSource.Slice(here, InputPosition - here)); };

	// Used by NumberSuffix to detect end-of-suffix
	extern token EndId : ~('a'..'z'|'A'..'Z'|'0'..'9'|'_'|'#') | EOF;

	// Strings ---------------------------------------------------------------
		
	private token SQString returns [object result] :
		{_parseNeeded = false;}
		( '\'' ('\\' _ {_parseNeeded = true;} | ~('\''|'\\'|'\r'|'\n'))
			('\'' / {_parseNeeded = true;}) )
		{return ParseSQStringValue();};
	
	private token DQString returns [object result] :
		{_parseNeeded = false;}
		(	'"' [ '\\' _ {_parseNeeded = true;} | ~('"'|'\\'|'\r'|'\n') ]* 
			('"' / {_parseNeeded = true;}) )
		{return ParseStringValue(false);};
	
	[LL(4)] private token TQString returns [object result] :
		{_parseNeeded = true;}
		{_style = NodeStyle.Alternate;}
		(	'"' '"' '"' nongreedy(Newline(true) / _)* '"' '"' '"' 
			| {_style |= NodeStyle.Alternate2;}
				"'''"       nongreedy(Newline(true) / _)* "'''" )
		{return ParseStringValue(true);};

	private BQString2 :
		{_parseNeeded = false;}
		'`' ('\\' _ {_parseNeeded = true;} | ~('`'|'\\'|'\r'|'\n'))* '`';

	private token BQString returns [object result] : BQString2 {return ParseBQStringValue();} ;

	// Nontrivial punctuation & operators -----------------------------------
		
	private token OpChar :
		'~'|'!'|'%'|'^'|'&'|'*'|'-'|'+'|'='|'|'|'<'|'>'|'/'|'?'|':'|'.'|'$';
	private token Operator returns [object result] : 
		OpChar+ {return ParseNormalOp();} ;
	private token SQOperator returns [object result] : 
		"'" LettersOrPunc+ {return ParseNormalOp();} ;

	// Identifiers and Symbols -----------------------------------------------

	[inline] extern token IdStartChar : '#'|'_'|'a'..'z'|'A'..'Z' ;
	// FIXME: 0x80..0xFFFC makes LLLPG make a HashSet<int> of unreasonable size.
	private token IdExtLetter : &{char.IsLetter((char) $LA)} 0x80..0xFFFC ;
	private token NormalId : 
		(IdStartChar|IdExtLetter) (IdStartChar|'0'..'9'|'\''|IdExtLetter)*
		;
	private token FancyId : BQString2 | (LettersOrPunc | IdExtLetter)+ ;
	private token Symbol returns [object result] :
		{_parseNeeded = false;}
		'@' '@' FancyId
		{return ParseSymbolValue();};
	private token Id returns [object result] :
		{_parseNeeded = false;}
		( NormalId    {return ParseIdValue(false);}
		| '@' FancyId {return ParseIdValue(true);} );
	private token LettersOrPunc : '0'..'9'|'a'..'z'|'A'..'Z'|'_'|'#'|'\''
		|'~'|'!'|'%'|'^'|'&'|'*'|'-'|'+'|'='|'|'|'<'|'>'|'/'|'?'|':'|'.'|'$' ;

	// Shebang (optional feature) --------------------------------------------

	private token Shebang returns [object result] : 
		&{InputPosition == 0} "#!" ~('\r'|'\n')* Newline? 
		{return WhitespaceTag.Value;};

	// Token -----------------------------------------------------------------

	[LL(4)] public override token NextToken returns [Maybe<Token> result] 
		@init {
			Spaces();
			_startPosition = InputPosition;
			_style = 0;
			if (LA0 == -1) { // EOF
				return NoValue.Value;
			}
		}:
		( {_type = TT.Shebang;}   value:Shebang
		/ {_type = TT.Literal;}   value:Symbol
		/ {_type = TT.Id;}        value:Id
		/ {_type = TT.Newline;}   value:Newline
		/ {_type = TT.SLComment;} value:SLComment
		/ {_type = TT.MLComment;} value:MLComment
		/ {_type = TT.Literal;}   value:Number
		/ {_type = TT.Literal;}   value:TQString
		/ {_type = TT.Literal;}   value:DQString
		/ {_type = TT.Literal;}   value:SQString
		/ {_type = TT.BQString;}  value:BQString
		/                         value:SQOperator
		/ {_type = TT.Comma;}     ',' { _value = @@`;`; }
		/ {_type = TT.Semicolon;} ';' { _value = @@`,`; }
		/ {_type = TT.LParen;}    '('
		/ {_type = TT.RParen;}    ')'
		/ {_type = TT.LBrack;}    '['
		/ {_type = TT.RBrack;}    ']'
		/ {_type = TT.LBrace;}    '{'
		/ {_type = TT.RBrace;}    '}'
		/ {_type = TT.At;}        '@' { _value = @@``; }
		/                         value:Operator
		/ error ( EOF {_type = TT.EOF;}
		        | _   {_type = TT.Unknown;} )
		)
		{	Debug.Assert(InputPosition > _startPosition);
			return new Token((int) _type, _startPosition, InputPosition - _startPosition, _style, _value);
		};

	// Partial tokens used for syntax highlighting. An LES syntax highlighter
	// can record the token continued in each line (''', """ or /*) call one
	// of these rules to proces that token until it ends or the line ends.
		
	[LL(3)]
	token TDQStringLine returns [bool result] : 
		nongreedy(_)* (Newline(true) {return false;} | '"' '"' '"' {return true;});
	[LL(3)]
	token TSQStringLine returns [bool result] : 
		nongreedy(_)* (Newline(true) {return false;} | "'''" {return true;});
	public token MLCommentLine[ref int nested] returns [bool result] :
		(greedy
			( &{nested>0} "*/" {nested--;}
			/ "/*" {nested++;}
			/ ~('\r'|'\n'|'*')
			/ '*' (&!'/')
			))*
		(Newline(true) {return false;} | "*/" {return true;});

	}; // end LLLPG lexer
};

partial class Les3Parser
{
	#rawText("#pragma warning disable 162, 642");

	protected new const TT EOF = TT.EOF;

	[FullLLk, LL(1), AddCsLineDirectives(false)]
	LLLPG (parser(laType: TT, matchType: int, terminalType: Token, allowSwitch: true)) @{

	alias("@" = TT.At);
	alias(":" = TT.Colon);
	alias(";" = TT.Semicolon);
	alias("," = TT.Comma);
	alias("!" = TT.Not);
	alias("(" = TT.LParen);
	alias(")" = TT.RParen);
	alias("[" = TT.LBrack);
	alias("]" = TT.RBrack);
	alias("{" = TT.LBrace);
	alias("}" = TT.RBrace);

	public StmtList returns [VList<LNode> result] :
		{endMarker := TT.Semicolon;}
		result:ExprList(ref endMarker);

	members {
		void CheckEndMarker(ref TokenType endMarker, ref Token end)
		{
			if (endMarker != end.Type()) {
				if (endMarker == default(TT)) {
					endMarker = end.Type();
				} else {
					Error(-1, "Unexpected separator: {0} should be {1}",
						ToString(end.TypeInt), ToString((int) endMarker));
				}
			}
		}
		public VList<LNode> ExprList(VList<LNode> list = default(VList<LNode>))
		{
			var endMarker = default(TT);
			return ExprList(ref endMarker, list);
		}
	}

	// A sequence of expressions separated by commas OR semicolons.
	// The `ref endMarker` parameter tells the caller if semicolons were used.
	public ExprList[ref TokenType endMarker, VList<LNode> list = default(VList<LNode>)] returns [VList<LNode> result] :
		// `(/X)` is the same as `[X]?` except that in the first version, X is 
		// the default branch, which simplifies the output code in this case.
		{if (LT0.Value is string) { endMarker = TT.EOF; };} // possible JSON (allow comma as separator)
		(/ e:TopExpr)
		[	end:(","|";")
			{list.Add(e ?? MissingExpr());}
			{CheckEndMarker(ref endMarker, ref end);}
			({$e = null;} / e:TopExpr)
		]*
		{if ($e != null || end.Type() == TT.Comma) { list.Add(e ?? MissingExpr()); };}
		{return list;}
		;
	public ExprListLazy[Holder<TokenType> endMarker] returns [IEnumerable<LNode> result] :
		{if (LT0.Value is string) { endMarker = TT.EOF; };} // possible JSON (allow comma as separator)
		(/ e:TopExpr)
		[	end:(","|";")
			{yield return e ?? MissingExpr();}
			{CheckEndMarker(ref endMarker.Value, ref end);}
			({$e = null;} / e:TopExpr)
		]*
		{if ($e != null || end.Type() == TT.Comma) {yield return e ?? MissingExpr();}}
		;

	protected TopExpr returns [LNode result] :
		(	// @[Attributes]
			"@" "[" attrs:ExprList[attrs] "]"
		)*
		(	e:Expr[StartStmt]
		/	// Superexpression
			id:=TT.Id // identifier
			{var args = VList<LNode>.Empty;}
			args+=Expr[P.SuperExpr]
			(	{
					if ((TT)LA0 == TT.LParen) {
						var loc = args[args.Count - 2, args.Last].Range.End;
						Error(0, "Expected a space before '(' (possibly missing ';' or ',' at {0})", loc);
					};
				}
				args+=Particle
			)*
			{e = MarkSpecial(F.Call(id, args, id.StartIndex, args.Last.Range.EndIndex));}
		)
		{if ($"@".TypeInt != 0) { e = e.WithRange($"@".StartIndex, e.Range.EndIndex); };}
		{return e.PlusAttrs(attrs);};

	// Types of (normal) expressions:
	// - particles: ids, literals, (parenthesized), {braced}
	// - ++prefix_operators
	// - infix + operators
	// - suffix_operators++
	// - Special primary expressions:
	//   method_calls(with arguments), indexers[with indexes], generic!arguments
	[LL(1)]
	token Expr[Precedence context] returns [LNode result] :
		{Precedence prec;}
		e:PrefixExpr(context)
		greedy
		(	// Infix operator
			&{[Local] context.CanParse(prec=InfixPrecedenceOf(LT($LI)))}
			{if (!prec.CanMixWith(context)) {
				Error(0, "Operator '{0}' is not allowed in this context. Add parentheses to clarify the code's meaning.", LT0.Value); 
			};}
			t:(TT.NormalOp|TT.BQString|TT.Dot|TT.Assignment)
			rhs:=Expr(prec)
			{e = F.Call((Symbol) t.Value, e, rhs, e.Range.StartIndex, rhs.Range.EndIndex).SetStyle(NodeStyle.Operator);}
		|	// Method_calls(with arguments), indexers[with indexes], generic!arguments
			&{[Local] context.CanParse(P.Primary)}
			e=FinishPrimaryExpr(e)
		|	// Suffix operator
			&{[Local] context.CanParse(SuffixPrecedenceOf(LT($LI)))}
			t:TT.PreOrSufOp
			{e = F.Call(ToSuffixOpName((Symbol) t.Value), e, e.Range.StartIndex, t.EndIndex).SetStyle(NodeStyle.Operator);}
		)*
		{return e;};

	// Helper rule that parses one of the syntactically special primary expressions
	private FinishPrimaryExpr[LNode e] returns [LNode result] :
		(	// call(function)
			{var endMarker = default(TokenType);}
			"(" list:ExprList[ref endMarker] c:=")"
			{
				e = MarkCall(F.Call(e, list, e.Range.StartIndex, c.EndIndex));
				if (endMarker == TT.Semicolon) { e.Style = NodeStyle.Statement | NodeStyle.Alternate; };
			}
		|	// ! operator (generic #of)
			"!"
			{var args = new VList<LNode> { e }; int endIndex;}
			(	"(" args=ExprList[args] c:=")"  {endIndex = c.EndIndex;}
			/	T:=Expr[P.Primary]              {args.Add(T); endIndex = T.Range.EndIndex;}
			)
			{e = F.Call(S.Of, args, e.Range.StartIndex, endIndex).SetStyle(NodeStyle.Operator);}
		|	// Indexer / square brackets
			{var args = new VList<LNode> { e };}
			"[" args=ExprList[args] c:="]"
			{e = F.Call(S.IndexBracks, args, e.Range.StartIndex, c.EndIndex).SetStyle(NodeStyle.Operator);}
		)
		{return e;};

	private PrefixExpr[Precedence context] returns [LNode result] 
		:	// Prefix operator
			t:(TT.NormalOp|"!"|TT.BQString|TT.Dot|TT.Assignment|TT.PrefixOp|TT.PreOrSufOp) 
			e:Expr[PrefixPrecedenceOf(t)]
			{$result = F.Call((Symbol) t.Value, e, t.StartIndex, e.Range.EndIndex).SetStyle(NodeStyle.Operator);}
		|	result:Particle
		;

	// An Particle is:
	// - an (expression) in parenthesis or a tuple
	// - a literal or simple identifier
	//   - simple calls are also handled here, as a space optimization
	// - a token literal @{ ... }
	// - a prefix operator followed by an Expr
	// - a { block } in braces
	// - a [ list  ] in square brackets
	private Particle returns [LNode result]
		:	id:=TT.Id // identifier
			{$result = F.Id(id).SetStyle(id.Style);}
		|	lit:=TT.Literal // literal
			{$result = F.Literal(lit).SetStyle(lit.Style);}
		|	// @{Token literal}
			o:"@" 
			( "[" tree:TokenTree c:"]"
			| "{" tree:TokenTree c:"}" )
			{$result = F.Literal(tree, o.StartIndex, c.EndIndex);}
		|	// {statements; in; braces}
			"{" list:=StmtList "}" 
			{$result = F.Braces(list, $"{".StartIndex, $"}".EndIndex).SetStyle(NodeStyle.Statement);}
			// [list]
		|	"[" list:=ExprList "]"
			{$result = F.Call(S.Array, list, $"[".StartIndex, $"]".EndIndex).SetStyle(NodeStyle.Expression);}
		|	// (parens) - possibly a tuple
			{var endMarker = default(TT);}
			"(" {var hasAttrList = (TT)LA0 == TT.LBrack || (TT)LA0 == TT.At;}
			list:=ExprList[ref endMarker]
			")" {
				if (endMarker == TT.Semicolon || list.Count != 1) {
					$result = F.Call(S.Tuple, list, $"(".StartIndex, $")".EndIndex);
					if (endMarker == TT.Comma) {
						var msg = "Tuples require ';' as a separator.";
						ErrorSink.Write(Severity.Error, list[0].Range.End, msg);
					};
				} else {
					$result = hasAttrList ? list[0] : F.InParens(list[0], $"(".StartIndex, $")".EndIndex);
				};
			}
		|	error {
				Error(0, "Expected a particle (id, literal, {braces} or (parens)).");
				$result = MissingExpr();
			};

	TokenTree returns [TokenTree result] :
		{$result = new TokenTree(SourceFile);}
		nongreedy(
			open:=("("|"["|"{")
			TokenTree
			{$result.Add(open.WithValue($TokenTree));}
			result+=(")"|"]"|"}")
		/	result+=_
		)*;

	}; // end LLLPG parser
}
