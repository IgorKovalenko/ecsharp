<#@ template language="C#" #>
<#@ output extension="cs" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Runtime.InteropServices" #>

namespace Loyc.Math
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Text;
	using System.Diagnostics;

	<# foreach (var T in _types) { #>

    public partial struct <#=T#>
    {
        public static <#=T#> Prescaled(<#=T.Int#> n) { <#=T#> r = new <#=T#>(); r.N = n; return r; }
        public static readonly <#=T#> Zero = new <#=T#>();
		public static readonly <#=T#> One = new <#=T#>(1);
		public static readonly <#=T#> Epsilon = Prescaled(1);
        public static readonly <#=T#> MaxValue = Prescaled(<#=T.Int#>.MaxValue);
        public static readonly <#=T#> MinValue = Prescaled(<#=T.Int#>.MinValue);
        public const <#=T.Int#> MaxInt = <#=T.Int#>.MaxValue >> <#=T.Frac#>;
        public const <#=T.Int#> MinInt = <#=T.Int#>.MinValue >> <#=T.Frac#>;
        public const double MaxDouble = <#=T.Int#>.MaxValue / (double)(1 << <#=T.Frac#>);
        public const double MinDouble = <#=T.Int#>.MinValue / (double)(1 << <#=T.Frac#>);
		public const <#=T.Int#> Mask = (1 << <#=T.Frac#>) - 1;

<#		if (T.WholeBits < 31) { #>
		public static explicit operator <#=T#>(int value) { return new <#=T#>(value); }
<#			if (T.WholeBits >= 15) { #>
		public static implicit operator <#=T#>(short value) { return new <#=T#>(value); }
<#			} else if (T.WholeBits >= 7) { #>
		public static implicit operator <#=T#>(sbyte value) { return new <#=T#>(value); }
<#			} #>
<#		} else { #>
		public static implicit operator <#=T#>(int value) { return new <#=T#>(value); }
<#		} #>
		
<#		if (T.WholeBits < 32) { #>
		public static explicit operator <#=T#>(uint value) { return new <#=T#>(value); }
<#			if (T.WholeBits >= 15) { #>
		public static implicit operator <#=T#>(ushort value) { return new <#=T#>(value); }
<#			} else if (T.WholeBits >= 7) { #>
		public static implicit operator <#=T#>(byte value) { return new <#=T#>(value); }
<#			} #>
<#		} else { #>
		public static implicit operator <#=T#>(uint value) { return new <#=T#>(value); }
<#		} #>

		public static explicit operator <#=T#>(long value) { return new <#=T#>(value); }
		public static explicit operator <#=T#>(ulong value) { return new <#=T#>(value); }
		public static explicit operator <#=T#>(float value) { return new <#=T#>(value); }
		public static explicit operator <#=T#>(double value) { return new <#=T#>(value); }
		public static explicit operator int(<#=T#> value) { return (int)(value.N >> <#=T.Frac#>); }
		public static explicit operator long(<#=T#> value) { return value.N >> <#=T.Frac#>; }
		public static explicit operator uint(<#=T#> value) { return (uint)(value.N >> <#=T.Frac#>); }
		public static explicit operator ulong(<#=T#> value) { return (ulong)(value.N >> <#=T.Frac#>); }
		public static explicit operator float(<#=T#> value) { return (float)value.N * (1.0f / (1 << <#=T.Frac#>)); }
		public static explicit operator double(<#=T#> value) { return (double)value.N * (1.0 / (1 << <#=T.Frac#>)); }

		public <#=T.Int#> N;

		private void Overflow()
		{
 			throw new OverflowException();
		}
<#		if (int.MinValue < T.MinInt || int.MaxValue > T.MaxInt) { #>
		public <#=T#> CheckedCast(int num)
		{
			if (num < MinInt<# if (int.MaxValue > T.MaxInt) { #> || num > MaxInt <# } #>)
				Overflow();
			return Prescaled(num << <#=T.Frac#>);
		}
<#		} #>
<#		if (uint.MaxValue > T.MaxInt) { #>
		public <#=T#> CheckedCast(uint num)
		{
			if (num > MaxInt)
				Overflow();
			return Prescaled((int)num << <#=T.Frac#>);
		}
<#		} #>
		public <#=T#> CheckedCast(long num)
		{
			if (num < MinInt || num > MaxInt)
				Overflow();
			return Prescaled((int)num << <#=T.Frac#>);
		}
		public <#=T#> CheckedCast(ulong num)
		{
			if (num > MaxInt)
				Overflow();
			return Prescaled((int)num << <#=T.Frac#>);
		}
		public <#=T#> CheckedCast(double num)
		{
			if (!(num >= MinDouble && num <= MaxDouble))
				Overflow();
			return FastCast(num);
		}
		public <#=T#> FastCast(int num)
		{
			return Prescaled(num << <#=T.Frac#>);
		}
		public <#=T#> FastCast(uint num)
		{
			return Prescaled((int)num << <#=T.Frac#>);
		}
		public <#=T#> FastCast(double num)
		{
			return Prescaled((int)Math.Round(MathEx.ShiftLeft(num, <#=T.Frac#>)));
		}

		public <#=T#>(int num)
		{
			N = num << <#=T.Frac#>;
<#			if (T.WholeBits < 31) { #>
			if (num < MinInt)
				N = <#=T.Int#>.MinValue;
			if (num > MaxInt)
				N = <#=T.Int#>.MaxValue;
<#			} #>
		}
		public <#=T#>(uint num)
		{
			N = (int)num << <#=T.Frac#>;
<#			if (T.WholeBits < 32) { #>
			if (num > (uint)MaxInt)
				N = <#=T.Int#>.MaxValue;
<#			} #>
		}
        public <#=T#>(long num)
		{
			N = (int)num << <#=T.Frac#>;
			if (num < MinInt)
				N = <#=T.Int#>.MinValue;
			if (num > MaxInt)
				N = <#=T.Int#>.MaxValue;
		}
		public <#=T#>(ulong num)
		{
			N = (int)num << <#=T.Frac#>;
			if (num > MaxInt)
				N = <#=T.Int#>.MaxValue;
		}
        public <#=T#>(double num)
		{
			N = (int)Math.Round(MathEx.ShiftLeft(num, <#=T.Frac#>));
			if (num <= MinDouble)
				N = <#=T.Int#>.MinValue;
			if (num >= MaxDouble)
				N = <#=T.Int#>.MaxValue;
		}

		public static <#=T#> operator +(<#=T#> a, int b) { a.N += b << <#=T.Frac#>; return a; }
        public static <#=T#> operator -(<#=T#> a, int b) { a.N -= b << <#=T.Frac#>; return a; }
        public static <#=T#> operator *(<#=T#> a, int b) { a.N *= b; return a; }
        public static <#=T#> operator /(<#=T#> a, int b) { a.N /= b; return a; }
        public static <#=T#> operator %(<#=T#> a, int b) { a.N %= b << <#=T.Frac#>; return a; }
		public static <#=T#> operator +(<#=T#> a, <#=T#> b) { a.N += b.N; return a; }
        public static <#=T#> operator -(<#=T#> a, <#=T#> b) { a.N -= b.N; return a; }
        
<#		if (T.IsLong) { #>
		public static <#=T#> operator *(<#=T#> a, <#=T#> b)
		{
			var afrac = a.N & Mask;
			var bfrac = b.N & Mask;
			var whole = (<#=T#>)((<#=T.Int#>)a * (<#=T.Int#>)b);
			whole.N += afrac * bfrac >> <#=T.Frac#>;
			return whole;
		}
        public static <#=T#> operator /(<#=T#> a, <#=T#> b)
		{
			long whole = a.N / b.N;
			long remainder = a.N % b.N;
			remainder = (remainder << <#=T.Frac#>) / b.N;
			Debug.Assert(remainder < (1 << <#=T.Frac#>));
			a.N = (whole << <#=T.Frac#>) + remainder;
			return a;
			// TODO: test negative numbers: 7 / -2.5, -7 / 2.5, -7 / -2.5
		}
<#		} else { #>
		public static <#=T#> operator *(<#=T#> a, <#=T#> b) { return Prescaled((int)((long)a.N * (long)b.N >> <#=T.Frac#>)); }
        public static <#=T#> operator /(<#=T#> a, <#=T#> b) { return Prescaled((int)((long)(a.N << <#=T.Frac#>) / b.N)); }
<#		} #>
        public static <#=T#> operator %(<#=T#> a, <#=T#> b) { a.N %= b.N; return a; }
		public static <#=T#> operator <<(<#=T#> a, int b) { a.N <<= b; return a; }
		public static <#=T#> operator >>(<#=T#> a, int b) { a.N >>= b; return a; }
		public static bool operator ==(<#=T#> a, <#=T#> b) { return a.N == b.N; }
		public static bool operator !=(<#=T#> a, <#=T#> b) { return a.N != b.N; }
		public static bool operator >=(<#=T#> a, <#=T#> b) { return a.N >= b.N; }
		public static bool operator <=(<#=T#> a, <#=T#> b) { return a.N <= b.N; }
		public static bool operator >(<#=T#> a, <#=T#> b) { return a.N > b.N; }
		public static bool operator <(<#=T#> a, <#=T#> b) { return a.N < b.N; }
		
		public override bool Equals(object obj)
		{
			return obj is <#=T#> && ((<#=T#>)obj).N == N;
		}
		public override int GetHashCode()
		{
			return N.GetHashCode();
		}
		public override string ToString()
		{
			return ((double)this).ToString();
		}
    }

	<# } #>
}

<#+
	class FPTraits {
		public FPTraits(Type intType, int fracBits, string name)
		{
			IntType = intType;
			Int = intType.Name;
			Frac = fracBits;
			Name = name;
			//IsSigned = intType == typeof(sbyte) || intType == typeof(short) || intType == typeof(int) || intType == typeof(long);
			WholeBits = Marshal.SizeOf(intType) * 8 - 1 - Frac;//(IsSigned ? 1 : 0);
			IsLong = intType == typeof(long) || intType == typeof(ulong);
			MaxInt = (long)(Convert.ToUInt64(intType.GetField("MaxValue").GetRawConstantValue()) / (1u << Frac));
			MinInt = (long)(Convert.ToInt64(intType.GetField("MinValue").GetRawConstantValue()) / (1 << Frac));
		}
		public long MaxInt, MinInt;
		public string Name;
		public string Int;
		public Type IntType;
		public bool IsLong;
		public int Frac;
		public int WholeBits;
		public override string ToString() { return Name; }
	};
	FPTraits[] _types = new FPTraits[]
	{
		new FPTraits(typeof(int), 8, "FPI8"), 
		new FPTraits(typeof(int), 16, "FPI16"),
		new FPTraits(typeof(int), 24, "FPI24"),
		new FPTraits(typeof(long), 16, "FPL16"), 
		new FPTraits(typeof(long), 32, "FPL32"),
		new FPTraits(typeof(long), 48, "FPL48")
	};
#>