// What is Loyc?
// -------------
//
// Loyc will be a collection of libraries and conventions that provide an 
// extensible infrastructure for writing computer languages and other tools that
// examine or modify source code. The initial goal is to support a superset of the
// C# language with additional features. To support other languages, one must 
// write a parser that converts the source language into an AST (abstract syntax
// tree) that other parts of Loyc can understand--basically, the code must be 
// converted to imperative code that uses the .NET type system.

// The Loyc AST & interchange format
// ---------------------------------
// 
// The AST is Loyc's central data structure, and is so important that there is a
// special language to represent a Loyc AST. Loyc ASTs are represented by a tree
// of mostly immutable AstNode objects. I felt that using an immutable tree would 
// be the best way to help components written by different people to work together 
// more reliably, since anyone can operate on an immutable AST without fearing 
// that some other code will change it.
// 
// When you need to modify an AstNode, you call one of the "With" methods (e.g. 
// WithChildren(new_children)) to make a modified version of the node. Then you
// must construct a new tree that includes the modified node. This is done using
// a functional code style (see example below.)
//
// AstNodes are not entirely immutable: the tree's structure is immutable, but 
// immutability is expensive, since modifying any node in the tree requires one
// to make a copy of all of that node's parents. To avoid this hassle during 
// AST analysis (which determines the semantics of an AST without changing its
// structure), the Value of a node can be set IF it is null, and each node has a 
// mutable collection of "tags". This collection is held in a special data 
// structure called a WList, which can be duplicated instantly. Tags are used to 
// annotate an AST with additional information, such as the data type of an 
// expression.
// 
// An AstNode has five parts:
//
// - a node type (the NodeType property)
// - a Value property (any object)
// - a list of children (the Children property)
// - a SourceRange (the Range property)
// - Tags (maps Symbols to objects; tags are accessed through the Tags property
//   or the GetTag and SetTag methods)
// 
// A tree of AstNodes can be serialized to "Loyc AST Interchange Format" or LAIF,
// which looks like this:
// 
// Op[:"+"] (ID["a"] INT[1])
//
// This tree basically represents the expression "a + 1". It defines a node of type 
// :Op, with a Value that is a Symbol named "+". It has two children: an :ID 
// (identifier) "a" and an :INT (integer literal) 1.
// 
// The above tree only tells us the NodeType, Value and children of each AstNode. 
// A more detailed tree is possible that includes the Range and tags:
//
// #in @"C:\foo.cs"
// Op[:"+"] //@2345:1\\ {Op:{Op TODO}} (
//   ID["a"] //@2343:1\\ INT[1] //@2347:1\\
// )
//
// Having serialized the AST to LAIF like this, it can be deserialized back to a 
// tree again. Looking at code in this form allows us to visualize intermediate
// stages of the compiler; in many cases, another option is to write out the AST
// in C# form.
//
// From this syntax we get a shorthand notation for talking about AstNodes. For
// example, a Type[:Method] node is an AstNode whose NodeType is :Type and whose
// Value is :Method.
//
// How to modify an AST
// --------------------
//
// As I was saying, you need to write functional code to modify an AST. Here is
// an example that deletes all "Foo" nodes that are children of a given node:
//
// 	static Symbol _Foo = Symbol.Get("Foo");
// 	
// 	AstNode EliminateFoos(AstNode node)
// 	{
//		// RVList automatically allocates a new list if you change it
// 		RVList<AstNode> list = node.Children;
// 		
// 		for (int i = 0; i < list.Count; i++)
// 			if (list[i].NodeType == _Foo)
// 				list.RemoveAt(i--);
// 			else {
// 				var child = EliminateFoos(list[i]);
//				if (list[i] != child) // only modify if it changes
// 					list[i] = child;
// 			}
// 		
//		// node.WithChildren() returns node itself if the list is unchanged
// 		return node.WithChildren(list);
// 	}
// 
// This is not a very good example.
//
// The children of a node are stored in an RVList<T>, which is an immutable list 
// data structure that bears no relation to motor homes. RVList provides a 
// standard mutable .NET interface. When you use that interface to modify the
// list, what you are really doing is making a copy of some or all of the list.
// Therefore, in the worst case the above method is very slow, because it copies
// most of the list repeatedly. For example, if the node has 100 children, and
// each child is changed, then on average, more than half of those 100 children
// are copied in each iteration of the loop.
//
// The following approach is potentially more efficient:
//
// 	AstNode EliminateFoos(AstNode node)
// 	{
// 		var node.WithChildren(
// 			node.Children
// 			.Filter(n => n.NodeType != _Foo)
// 			.SmartSelect(n => EliminateFoos(n)));
// 	}
// 
// Be sure to call SmartSelect() instead of Select(), which ensures that if the
// list doesn't change, the original list is used instead of building a new list.
// 
// An even better approach is to wrap the RVList in RWList:
//
// 	AstNode EliminateFoos(AstNode node)
// 	{
// 		RWList<AstNode> list = node.Children.ToRWList();
// 		
// 		for (int i = 0; i < list.Count; i++)
// 			if (list[i].NodeType == _Foo)
// 				list.RemoveAt(i--);
// 			else if (node.ChildCount != 0) {
// 				var child = EliminateFoos(list[i]);
//				if (list[i] != child) // only modify if it changes
// 					list[i] = child;
// 			}
// 		
//		// node.WithChildren() returns node itself if the list is unchanged
// 		return node.WithChildren(list.ToRVList());
// 	}
//
// This produces a garbage RWList on every node that has children (notice how 
// this method skips nodes with no children), but RWList is very small (4 
// words) so it won't bother the garbage collector much. RWList creates a
// mutable copy of the list when necessary, so this approach is is much faster
// if many children of a large node are changed.
//
// Lambda functions have overhead and produce garbage too (because Microsoft 
// unnecessarily decided to make delegates a reference type), moreso if your lambda
// functions access local variables outside the lambda, so this third example 
// should scan an AST faster than the second (though I didn't check).
//
// Note: Tags should be used sparingly, since the tag dictionary uses a list of 
// key-value pairs, not a hash table. Large numbers of tags cannot be managed 
// quickly, but accessing the same tag repeatedly is fast, since AstNode caches 
// the location of the last tag that was accessed.

// Ideas for AST node layouts
// --------------------------
//
// - Generics are handled by encapsulating a generic method or class in a :Generic
//   node
// - A type signature has type :Type. The :Type with Value=:Method is special; its
//   children are arguments (:Arg) instead of types (:Type). 'ref' and 'out' are 
//   considered attributes of an :Arg.
// - When type references are resolved, they are assigned as the :Type tag of the
//   type or expression node.
// - Children marked opt. are optional. To omit an optional child, use null.

// Declarations
// ------------
// 
// Most declarations can have attributes, so the first child of any declaration can
// refer to a list of attributes (:Attrs). For declarations that have a type, the
// type is specified as the second child. After parsing a source file, types have
// not yet been resolved, and a type node merely contains the name of the type,
// e.g. "int", as its Value property. If a name is qualified (e.g. "System.String")
// then the components of the fully qualified name become children of the type
// node. In C#, namespace aliases are represented with a string that has a "::" 
// suffix. For example, the type reference "A::B.C" becomes a node with Value="C" 
// and two children. The first child has the Value "A::", and the second, "B".
// 
// The name of a namespace, type, variable, delegate, or method is stored as a 
// string in the Value property of the :Namespace, :Class, :Struct, :Interface, 
// :Enum, :Var, :Delegate, :Property, or :Method node.
// 
// All type references have type :Type. Unqualified type references such as "int" 
// and "List<int>" have, as their Value property, the type name as a string. If 
// the type is generic, then the type arguments are specified as children that 
// also have type :Type. Array types are stored similarly, except that their Value 
// is the special Symbol "[]" (for multi-dimensional arrays, it's "[,]", "[,,]",
// etc.) An open generic type (e.g. "List<>") is represented by a list of children
// where the Value of each is the empty string "".
// 
// The void type can be represented by a Value of :Void. In cases where no type is 
// specified, a value of :Infer can be used.
//
// If a type reference is qualified, then the dots ("." or "::") between the names
// are treated a lot like left-associative binary operators. The top-level :Type
// node has a Value that is a Symbol for "::" or "." (depending on how it is 
// qualified). The first child specifies a path, while the second child represents
// the type name on the right-hand side.
// 
// Basically, "global::Foo<int>.Bar" is parsed as "(global :: (Foo<int>)) . Bar".
// This means that the top-level node is named "." (which means its Value is ".").
// "." has two children, the first is named "::" and the second is "Bar". "::" has
// two children, "global" and "Foo". "Foo" has a single child named "int". All of
// these nodes have the same NodeType, :Type.
// 
// Note: it is important that "[]", "::" and "." are represented as Symbols, not 
// strings, in order to distinguish them from type names; theoretically it might 
// be possible that a type is actually named "." or "::", so we distinguish the 
// two possibilities by type (string for a type name, Symbol for an operator or an
// array).
// 
// Raw function types (not to be confused with delegate types) are represented by
// :Type nodes with a Value of :Method. The children of this node are argument 
// nodes of type :Arg. :Arg has two children: a list of attributes, and a :Type.
// If an argument has a name, it is stored in the Value of the :Arg node.
//
// The second child of a :Method or :Delegate node specifies the method signature 
// as a Type[:Method] node. :MethodType's children have type :Arg, and specify the 
// type and (optionally) attributes of each parameter and return value. A method
// can only return one value; languages in which multiple return values are allowed
// must either use a tuple type to store the set of return values, or transform
// their methods so that extra arguments are represented by 'out' parameters.
// 
// 'ref' and 'out' parameters are represented by attributes of type :Ref or :Out.
// At each call site that uses the 'ref' or 'out' keyword, a :Ref or :Out node is
// produced with the actual argument as a child of that node.
// 
// The :Var node is used to define both fields and local variables.
// 
// :Using              : opt.attrs  opt.alias  namespace*
// :Namespace          : opt.attrs  members(:Block)
// :Class, :Struct,
// :Interface, :Enum   : opt.attrs  bases(:Bases)  members(:Block)
//     :Bases          : base-type  interface-type*
// :Property           : opt.attrs  type  opt.getter(:Method)  opt.setter(:Method)
// :Method, :Delegate  : opt.attrs  type  opt.code-block(:Block)
// :Type for a method  : return-type(:Arg)  arg-types(:Arg)*
// :Arg                : opt.attrs  type
// :Var                : opt.attrs  type
// type (:Type) : generic-args*
//
// Note that the :Var node has no slot for the initial value. If there is an
// initial value, the :Var node is wrapped in an assignment operator as explained
// in the "Statements" section.

// Attributes
// ----------
// 
// Each attribute is either a custom attribute (:Attr) or a language-specific
// attribute (typically represented by an :ID token) A custom attribute has a list
// of arguments as its children. An argument to an attribute is an expression; 
// named parameters have type :Assign where the first child refers to the name of 
// the parameter.
// 
// :Attrs              : attr(:Attr)*
// :Attr               : args*

// Generics
// --------
//
// Generics definitions are represented by wrapping another node (such as :Method
// or :Class) in a :Generic node.
// 
// :Generic            : node generic-param*
// :GenericParam       : opt.attrs name constraint*
// 
// Explicitly generic method calls are represented by giving children to the ID
// node that represents the method name; each child has type :Type. Generic type 
// references such as List<int> are represented by a :Type node. The Value of the 
// node is the type name ("List") and each type argument is a child of that node 
// that also has type :Type.

// Statements
// ----------
// 
// In Loyc, the distinction between statements and expressions is purely syntactic;
// in other words, what is a statement and what is an expression depends on the 
// source language. In C#, statements can only occur at "statement boundaries" 
// (such as at the beginning of a { block }, or after another statement ends).
// 
// What we call "statements" usually do not return a value, but this may be true 
// of expressions (e.g. Console.WriteLine()) that don't return anything, either.
// There are perhaps more meaningful distinctions we can make than between 
// "statement" and "expression":
// 
// - Declarations versus executable code
// - Code that has a value versus code that doesn't (is "void")
// 
// Anyway, in this section I'll discuss a few executable constructs that are
// typically thought of as "statements".
// 
// The traditional if-else statement can be used as an expression in Loyc; in other
// words, it can return a value provided that both branches return a value. "if" 
// statements (without an else clause) do not return a value. An "else-if" clause
// is parsed into an "if" statement nested in the "else" branch.
// 
// Standard loops do not return values.
// 
// A code block (:Block) can return a value. It behaves similarly to the C comma 
// operator: all statements of the block are evaluated in order, then the value of 
// the last statement of the block is considered to be the value of the block.
// 
// Variable declarations return an (unassigned) lvalue that can then be used in an
// expression. The C# statement
// 
//    int a = 1;
// 
// is parsed as "(int a) = 1", where the "int a" part is a :Var node. In other
// words, the variable declaration is nested in an assignment expression.
// 
// Expressions
// -----------
// 
// All operations that have arguments have type :Op. The Value of an :Op node
// indicates the operation to be performed as a reference to an AstNode that 
// identifies the operation (typically a token from the lexer). During or after 
// parsing, this Value is resolved to an Op object that represents the 
// operation, and this is assigned to the :Op tag of the :Op node.
// 
// Some operations, or "ops", are represented by operators (a shorthand notation
// such as 2+2) while others are represented by function calls (e.g. add(2, 2)).
// 
// Operators can be divided into several categories:
// 
// - prefix, postfix, binary, and ternary operators (e++, ++e, e+e, e?e:e)
// - punctuation and word operators ("+" vs "is")
// - executable and declarative operators ("+" vs ".")
// - operators that short-circuit and those that don't ("&&" vs "&")
// 
// Prefix and postfix operators that have the same name can be hard to distinguish.
// Unary operators should be assumed to be prefix by default; the parser should 
// assign a value to the :Op tag to make reference to a postfix operator. Likewise,
// the Value of a ternary op can only refer to one token of the operator, so the
// :Op tag is needed to specify the operator. 
//
// Operators normally have children that are expressions, but the second child
// of the "is" and "as" operators are types (:Type).
// 
// Loyc's canonical language is C#. Parsers for languages other than C# also need
// to use the :Op tag whenever the operator's name is different from that used in 
// C#. For example, if there is an "and" operator, an :Op tag that refers to the
// Op for "&&" is needed.
// 
// Not all operators are executable. The special operators dot (.) and
// scope-resolution (::) also have type :Op, but they are evaluated at compile
// time.
// 
// Expression components that do not have arguments typically have a different
// type than :Op.
//
// Identifiers (whether qualified or not) are not normally resolved at parse time,
// so the parser can normally just place the ID token directly into the expression
// tree. Dot (.) and scope resolution (::) are treated like special
// left-associative operators, so "foo::a.b.c" is parsed as "((foo::a).b).c". If 
// an identifier includes generic type arguments, these become children of an ID 
// node.
// 
// Literals are represented simply by the token that the lexer produced for them,
// but with the Value set to the value of the literal. For example, the text of
// the C# string literal @"foo" is "@\"foo\""; the lexer output is postprocessed
// to set the Value of this token to "foo".
// 
// If necessary, parenthesis can be represented by a node of type :Expr. For
// evaluation purposes, this is treated as a no-op.
// 
// Casts are represented as a node of type :Cast. For consistency with the "is" and
// "as" operators, a cast has type :Op with a Value of :Cast, and the second child
// (not the first!) specifies the target type.
// 
// An expression can directly contain a code block (:Block) as a subexpression.
// This behaves similarly to the C comma operator: the all statements of the block
// are evaluated in order, then the value of the last statement of the block is
// considered to be the value of the block.


// Parser description for the parser generator - for now, let's parse tokens, not
// text, since we already have a boo lexer.
tree parser ParserGeneratorParser:
	_parsers = List(of AstNode)
	
	option TerminalType=AstNode
	option TerminalSet=SymbolSet
	option LL=2
	
	// Each rule can have an argument list, and each rule can return a value.
	start rule Code:
		( Parser
		| "namespace" ID ":" INDENT (^Code) DEDENT
		| .
		)+
	
	rule Parser:
		"tree"? "parser" ID ":" INDENT (^
			option LL=1 ParserParts+=(Rule | Options | .)*
		) DEDENT
		
		-> :Parser (^ID :Parts (^ParserParts*))
		
	rule Rule:
		tag="rule" ID (args=LPAREN RPAREN | args=LBRACK RBRACK)? ":" 
			INDENT (^Expr) DEDENT
		
		-> :Rule[tag] (^ {null} ID args :Parts (^ParserParts*))
		
	rule Expr:
		Alternative (("|" | "/") Alternative)* ("->" RewriteExpr)?
	
	rule RewriteExpr:
		RewritePart*
	
	rule Alternative:
		(MatchPart | GateOrPredicate | Code)*
	
	rule MatchPart:
		Options?
		MatchAtom[true]
		("?" | "*" | "+")?

	rule RewritePart:
		MatchAtom[false]
		("?" | "*" | "+")?
	
	rule MatchAtom(matching as bool = true):
		(	"$"
		|	( {matching}? ID ("=" | "+=") {assignment=true} )?
			( 
			  (ID | SYMBOL | DQSTRING | "." | NegativeSet |
			   {assignment}? LPAREN (^TerminalSet) RPAREN)
			  (LBRACK (^.+) RBRACK)? // :Type[Value]
			)
			( LPAREN "^" Expr RPAREN )?
		)
		// Example atoms:
		//    INT
		//    name=ID
		//    name=(ID|INT|REAL)
		//    INT[0]
		//    LPAREN (^Expr)
	
	rule Predicate:          SemanticPredicate / SyntacticPredicate
	rule Gate:               Predicate "=>" Alternative
	rule GateOrPredicate:    Predicate ("=>"? Alternative)
	rule SemanticPredicate:  "&" LBRACE (^.+) RBRACE | LBRACE (^.+) RBRACE "?"
	rule SyntacticPredicate: "&" MatchPart
	rule Code:               ^LBRACE
	
	rule TerminalSet:        TerminalSetPart ("|" TerminalSetPart)*
	rule TerminalSetPart:    "~"? (ID | SYMBOL | LPAREN (^TerminalSet) RPAREN)
	rule NegativeSet:        "~" TerminalSetPart
	rule NonterminalWithArgs: ID ^LBRACK

	rule Options:
		("option" | "options") Option ("," Option)* "in"?
	rule Option:
		ID ("=" .)?
