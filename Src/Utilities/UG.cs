using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using NUnit.Framework;
using System.Text.RegularExpressions;
using System.IO;
using Loyc.Geometry;

namespace Loyc.Utilities
{
	public static class UG
	{
        /// <summary>
        /// Expands environment variables (e.g. %TEMP%) and @files in a list of
        /// command-line arguments, and adds any options of the form "--opt" or
        /// "--opt=value" to a dictionary.
        /// </summary>
        /// <param name="args">The original arguments to process</param>
        /// <param name="options">Any --options found will go here, and their keys
        /// will be converted to lowercase, unless this parameter is null. Note that
        /// options are not removed or converted to lowercase in the original args
        /// list.</param>
        /// <param name="atPath">If a parameter has the form @filename, the folder
        /// specified by atPath will be searched for an options text file with that
        /// filename, and the contents of the file will be expanded into the list of
        /// arguments (split using SplitCommandLineArguments).</param>
        /// <param name="argLimit">A limit placed on the number of arguments when
        /// expanding @files. Such a file may refer to itself, and this is the only
        /// protection provided against infinite recursive expansion.</param>
        /// <remarks>
        /// Options are expected to have the form -ID=value, where ID matches the
        /// regex "[a-zA-Z_0-9]+". If there is no "=", that's okay too. For example,
        /// --ID{foo} is equivalent to --Id={foo}; both result in the name-value
        /// pair ("id", "{foo}").
        /// </remarks>
		public static void ProcessCommandLineArguments(List<string> args, Dictionary<string, string> options, string atPath, int argLimit)
		{
			for (int i = 0; i < args.Count; i++)
				if (ProcessArgument(args, i, options, atPath, argLimit))
					i--; // redo
		}
		public static readonly Regex CmdLineArgRegex = new Regex(@"^--([a-zA-Z_0-9]+)([=]?(.*))?$");

		private static bool ProcessArgument(List<string> args, int i, Dictionary<string, string> pairs, string atPath, int argLimit)
		{
			string s = args[i];
			args[i] = s = Environment.ExpandEnvironmentVariables(s);

			if (pairs != null) {
				Match m = CmdLineArgRegex.Match(s);
				if (m.Success) {
					// it's an --option
					string name = m.Groups[1].ToString();
					string value = m.Groups[3].ToString();
					try {
						pairs.Add(name.ToLower(), value);
					} catch {
						Output.Write(GSymbol.Get("Warning"), "Option {0} was specified more than once. The first value, {1}, will be used.",
							name, pairs[name]);
					}
				}
			}
			if (atPath != null && s.StartsWith("@")) {
				// e.g. "@list of options.txt"
				try {
					string fullpath = Path.Combine(atPath, s.Substring(1));
					if (File.Exists(fullpath))
					{
						string fileContents = File.OpenText(fullpath).ReadToEnd();
						List<string> list = G.SplitCommandLineArguments(fileContents);
						
						args.RemoveAt(i);
						
						int maxMore = System.Math.Max(0, argLimit - args.Count);
						if (list.Count > maxMore) {
							// oops, command limit exceeded
							Output.Write(GSymbol.Get("Warning"), "{0}: Limit of {1} commands exceeded", s, argLimit);
							list.RemoveRange(maxMore, list.Count - maxMore);
						}
						
						args.InsertRange(i, list);

						return true;
					}
				} catch (Exception e) {
					Output.Write(GSymbol.Get("Error"), s + ": " + e.Message);
				}
			}
			return false;
		}
	}

	[TestFixture]
	public class UGTests : Assert
	{
		[Test] public void TestProcessCommandLineArguments()
		{
			// TODO: trap warning message generated by ExpandCommandLineArguments

			// Generate two options files, where the first refers to the second
			string atPath = Environment.ExpandEnvironmentVariables("%TEMP%");
			string file1 = "test_g_expand_1.txt";
			string file2 = "test_g_expand_2.txt";
			StreamWriter w = new StreamWriter(Path.Combine(atPath, file1));
			w.WriteLine("@"+file2+" fox--jumps\n--over the hill");
			w.Close();
			w = new StreamWriter(Path.Combine(atPath, file2));
			w.WriteLine("\"%TEMP%\"");
			w.Close();

			// Expand command line and ensure that the arg limit of 4 is enforced
			List<string> args = G.SplitCommandLineArguments("\"@"+file1+"\" \"lazy dog\"");
			Dictionary<string, string> pairs = new Dictionary<string, string>();
			UG.ProcessCommandLineArguments(args, pairs, atPath, 4);

			Assert.AreEqual(4, args.Count);
			Assert.AreEqual(args[0], atPath);
			Assert.AreEqual(args[1], "fox--jumps");
			Assert.AreEqual(args[2], "--over");
			Assert.AreEqual(args[3], "lazy dog");
			Assert.AreEqual(1, pairs.Count);
			Assert.AreEqual(pairs["over"], "");
		}
	}
}
