<#@ template language="C#" #>
<#@ output extension="cs" #>
<#@ include file="../../Essentials/Math/NumTraits.ttinclude" #>
<#@ import namespace="System.Collections.Generic" #>

namespace Loyc.Math
{
}

<# IList<string> types = new string[] { "I", "F", "D", "F8" }; #>
<# var           traits = _traits.Where(t => types.Contains(t.Abbrev)); #>
<# foreach(Traits T in traits) { #>
namespace Loyc.Math
{
	using System;
	using T = <#=T.QualifiedName#>;
	<# string Point2 = "Point2" + T.Abbrev; #>
	<# string Vector2 = "Vector2" + T.Abbrev; #>
	<# string Point3 = "Point3" + T.Abbrev; #>
	<# string Vector3 = "Vector3" + T.Abbrev; #>

	public struct <#=Point2#> : IEquatable<<#=Point2#>>, IPoint<<#=T#>>, INewPoint<<#=Point2#>,<#=T#>>
	{
		public static readonly <#=Point2#> Origin = new <#=Point2#>();
		public static readonly <#=Point2#> Infinity = new <#=Point2#>(<#=T.PositiveInfinity#>, <#=T.PositiveInfinity#>);

		public <#=Point2#>(T x, T y) { _x = x; _y = y; }

		private <#=T#> _x, _y;
		public <#=T#> X { get { return _x; } set { _x = value; } }
		public <#=T#> Y { get { return _y; } set { _y = value; } }

		public override bool Equals(object other) { return other is <#=Point2#> && ((<#=Point2#>)other) == this; }
		public override int GetHashCode() { return _x.GetHashCode() ^ _y.GetHashCode(); }
		public override string ToString() { return string.Format("({0},{1})", _x, _y); }
		
		public <#=Point2#> New(T x, T y) { return new <#=Point2#>(x, y); }
		IPoint<T> INewPoint<IPoint<T>, T>.New(T x, T y) { return new <#=Point2#>(x, y); }

		public static explicit operator <#=Vector2#>(<#=Point2#> p) { return new <#=Vector2#>(p.X, p.Y); }

<#		foreach(Traits T2 in traits.Where(t => t != T)) { #>
		public static explicit operator Point2<#=T2.Abbrev#>(<#=Point2#> p) { return new Point2<#=T2.Abbrev#>((<#=T2#>)p.X, (<#=T2#>)p.Y); }
<#		} #>

		public static <#=Point2#>  operator+(<#=Point2#> a, <#=Vector2#> b) { return new <#=Point2#>(a.X+b.X, a.Y+b.Y); }
		public static <#=Point2#>  operator+(<#=Vector2#> a, <#=Point2#> b) { return new <#=Point2#>(a.X+b.X, a.Y+b.Y); }
		public static <#=Point2#>  operator-(<#=Point2#> a, <#=Vector2#> b) { return new <#=Point2#>(a.X-b.X, a.Y-b.Y); }
		public static <#=Vector2#> operator-(<#=Point2#> a, <#=Point2#> b)  { return new <#=Vector2#>(a.X-b.X, a.Y-b.Y); }
		public static <#=Point2#>  operator*(<#=Point2#> p, T factor) { return new <#=Point2#>(p.X*factor, p.Y*factor); }
		public static <#=Point2#>  operator/(<#=Point2#> p, T factor) { return new <#=Point2#>(p.X/factor, p.Y/factor); }
		public static <#=Point2#>  operator<<(<#=Point2#> p, int amt) { return new <#=Point2#>(<#=T.ShiftLeft("p.X","amt")#>, <#=T.ShiftLeft("p.Y","amt")#>); }
		public static <#=Point2#>  operator>>(<#=Point2#> p, int amt) { return new <#=Point2#>(<#=T.ShiftRight("p.X","amt")#>, <#=T.ShiftRight("p.Y","amt")#>); }

		public static bool operator== (<#=Point2#> a, <#=Point2#> b) { return a.X == b.X && a.Y == b.Y; }
		public static bool operator!= (<#=Point2#> a, <#=Point2#> b) { return a.X != b.X || a.Y != b.Y; }
		public bool Equals(<#=Point2#> other) { return this == other; }
	}

	public struct <#=Vector2#> : IEquatable<<#=Vector2#>>, IPoint<<#=T#>>, INewPoint<<#=Vector2#>,<#=T#>>
	{
		public static readonly <#=Vector2#> Origin = new <#=Vector2#>();
		public static readonly <#=Vector2#> Infinity = new <#=Vector2#>(<#=T.PositiveInfinity#>, <#=T.PositiveInfinity#>);

		public <#=Vector2#>(T x, T y) { _x = x; _y = y; }

		private <#=T#> _x, _y;
		public <#=T#> X { get { return _x; } set { _x = value; } }
		public <#=T#> Y { get { return _y; } set { _y = value; } }
		
		public override bool Equals(object other) { return other is <#=Vector2#> && ((<#=Vector2#>)other) == this; }
		public override int GetHashCode() { return _x.GetHashCode() ^ _y.GetHashCode(); }
		public override string ToString() { return string.Format("({0},{1})", _x, _y); }

		public <#=Vector2#> New(T x, T y) { return new <#=Vector2#>(x, y); }
		IPoint<T> INewPoint<IPoint<T>, T>.New(T x, T y) { return new <#=Vector2#>(x, y); }
		
		public static explicit operator <#=Point2#>(<#=Vector2#> p) { return new <#=Point2#>(p.X, p.Y); }

<#		foreach(Traits T2 in traits.Where(t => t != T)) { #>
		public static explicit operator Vector2<#=T2.Abbrev#>(<#=Vector2#> p) { return new Vector2<#=T2.Abbrev#>((<#=T2#>)p.X, (<#=T2#>)p.Y); }
<#		} #>
		
		public static <#=Vector2#> operator+(<#=Vector2#> a, <#=Vector2#> b) { return new <#=Vector2#>(a.X+b.X, a.Y+b.Y); }
		public static <#=Vector2#> operator-(<#=Vector2#> a, <#=Vector2#> b) { return new <#=Vector2#>(a.X-b.X, a.Y-b.Y); }
		public static <#=Vector2#> operator*(<#=Vector2#> p, T factor) { return new <#=Vector2#>(p.X*factor, p.Y*factor); }
		public static <#=Vector2#> operator/(<#=Vector2#> p, T factor) { return new <#=Vector2#>(p.X/factor, p.Y/factor); }
		public static <#=Vector2#> operator<<(<#=Vector2#> p, int amt) { return new <#=Vector2#>(<#=T.ShiftLeft("p.X","amt")#>, <#=T.ShiftLeft("p.Y","amt")#>); }
		public static <#=Vector2#> operator>>(<#=Vector2#> p, int amt) { return new <#=Vector2#>(<#=T.ShiftRight("p.X","amt")#>, <#=T.ShiftRight("p.Y","amt")#>); }

		/// <summary>Dot product. a*b equals lhs.Length*rhs.Length*Cos(theta) if theta 
		/// is the angle between two vectors.</summary>
		public static T operator*(<#=Vector2#> a, <#=Vector2#> b) { return a.X*b.X + a.Y*b.Y; }
		/// <summary>Computes the "cross product" of a pair of vectors.</summary>
		/// <remarks>
		/// This is not a general cross product, as cross product is only a 3D concept,
		/// but this operator acts as though the two points were in the Z=0 plane and
		/// returns the Z coordinate of the cross product: b.X * a.Y - b.Y * a.X.
		/// This value is zero if the vectors are parallel; it is a.Length * b.Length 
		/// or -a.Length * b.Length if the vectors are perpendicular. One use of 
		/// cross product is to determine whether the angle between two lines is greater 
		/// or less than 180 degrees, corresponding to return values less or greater than 
		/// zero.
		/// </remarks>
		public T Cross(<#=Vector2#> b) { return X * b.Y - Y * b.X; }
		/// <summary>Rotates a vector 90 degrees.</summary>
		/// <remarks>
		/// Rotatation is clockwise if increasing Y goes downward, counter-
		/// clockwise if increasing Y goes upward. If the vector represents the 
		/// direction of a line, the result also represents the coefficients 
		/// (a,b) of the implicit line equation aX + bY + c = 0.
		/// </remarks>
		public <#=Vector2#> Rot90() { return new <#=Vector2#>(-Y, X); }
		/// <summary>Reverses a vector.</summary>
		public static <#=Vector2#> operator-(<#=Vector2#> a) { return new <#=Vector2#>(-a.X, -a.Y); }

		public static bool operator== (<#=Vector2#> a, <#=Vector2#> b) { return a.X == b.X && a.Y == b.Y; }
		public static bool operator!= (<#=Vector2#> a, <#=Vector2#> b) { return a.X != b.X || a.Y != b.Y; }
		public bool Equals(<#=Vector2#> other) { return this == other; }
		
		/// <summary>Gets the square of the length of the vector.</summary>
		public T Quadrance { get { return X*X + Y*Y; } }
		/// <summary>Gets the length of the vector.</summary>
		public T Length { get { return <#=T.Sqrt("Quadrance")#>; } }
		
		/// <summary>Gets the angle from 0 to 2*PI of the vector, where (1,0) has 
		/// angle 0 and (0,1) has angle PI/2.</summary>
		public double Angle
		{ 
			get {
				double angle = Math.Atan2((double)Y, (double)X);
				if (angle < 0)
					return angle + 2*Math.PI; 
				return angle;
			}
<#			if (T.CSharpName == "double") { #>
			set {
				this = FromPolar(Length, value);
			}
<#			} #>
		}

<#		if (T.CSharpName == "double") { #>
		public static <#=Vector2#> FromPolar(T magnitude, T angle)
		{
			return new <#=Vector2#>((T)Math.Cos((double)angle)*(double)magnitude,
			                        (T)Math.Sin((double)angle)*(double)magnitude);
		}

<#		} #>
<#		if (!T.IsInt) { #>
		public bool Normalize()
		{
			T len = Length;
			if (len == <#=T.Zero()#>)
				return false;
			if (len != <#=T.One()#>) {
				X /= len;
				Y /= len;
			}
			return true;
		}
		
		public <#=Vector2#> Normalized()
		{
			<#=Vector2#> v = this;
			v.Normalize();
			return v;
		}

<#		} // !T.IsInt #>
		<#=Vector2#> MulDiv(T mul, T div)
		{
			return new <#=Vector2#>(<#=T.MulDiv("X", "mul", "div")#>, <#=T.MulDiv("Y", "mul", "div")#>);
		}
	}
}
<# } #>