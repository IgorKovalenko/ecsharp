[LoycParser] class BooTreeLexer(BaseParser):
	// TODO

[LoycTextParser] class BooLexer(BaseLexer):
	// Note: => has lower precedence than ||, |, /
	// blah => foo is treated like "blah .+" for the purpose of prediction
	// assume("foo") causes "foo" to be skipped with only a debug-build assertion 
	// that there is a match. Only fixed-length lists can be assumed away.
	// Disabling warnings:
	// - '/' disables warnings between rules at the same level, e.g.
	//   the warning is disabled for (a / b / a) obviously, but there will be no 
	//   warning for (a / b | a) or (a | b / a) either. There is a warning for 
	//   a | (b / a) and for (a / b) | a, but not for a / (b | a) or for 
	//   (a | b) / a.
	// - greedy(...) and nongreedy(...) both disable warnings when there is ambiguity
	//   between the exit alternative and the in-loop alternative. greedy is the 
	//   default.
	// - there are no warnings when one of the alternatives has a semantic or 
	//   syntactic predicate, unless the alternatives have identical predicates 
	//   at the same positions, e.g. there is still a warning for
	//   "begin" (&!"end" .)+ || "begin" (&!"end" .)+
	// Other warnings/errors:
	// Error: an alternative that may consume no input is not allowed in a loop
	// Warning: an alternative that may consume no input is ambiguous in an optional 
	//          element
	protected _keywords as IDictionary(of string, Symbol)
	
	rule AnyToken():
		match any nonfragment rule:
			save prediction in NodeType
		if NodeType == _ID:
			text = _source2.Substring(_startingPosition, _inputPosition - _startingPosition)
			type = _keywords[text]
			if !type.IsNull:
				NodeType = type
				
	rule WS() = WS_CHAR+
	
	////////////////////////////////////////////////////////////////////////////
	// Character classes
	fragment rule EOF()           = -1
	fragment rule NEWLINE_CHAR()  = '\n' || '\r'
	fragment rule WS_CHAR()       = ' ' || '\t'
	fragment rule CONTROL_CHAR()  = '\u0000'..'\u001F'
	fragment rule DIGIT_CHAR()    = '0'..'9'
	fragment rule HEXDIGIT_CHAR() = ('a'..'f' | 'A'..'F' | '0'..'9')
	fragment rule LETTER_CHAR():
		match {
			('a'..'z' || 'A'..'Z') ||
			&{ System.Char.IsLetter((char)c) } '\u0080'..'\uFFFE'
		}
	fragment rule BASIC_PUNC_CHAR():
		match {
			'.'|'~'|'!'|'@'|'$'|'%'|'^'|'&'|
			'*'|'-'|'+'|'='|'|'|','|'<'|'>'|'?'
		}
	
	////////////////////////////////////////////////////////////////////////////
	// Identifiers
	rule ID() =
		match ID_LETTER (ID_LETTER || DIGIT_CHAR)*
	fragment rule ID_LETTER():
		match {
			'_' || LETTER_CHAR ||
			'\\' (
				('"' => DQ_STRING) || ~(NEWLINE_CHAR || WS_CHAR)
			)
		}

	////////////////////////////////////////////////////////////////////////////
	// Whitespace & Comments
	rule WS() = WS_CHAR+               { _visibleToParser = false; }
	rule LINE_CONTINUATION():
		match '\\' NEWLINE_CHAR    { _visibleToParser = false; }
	rule NEWLINE():
		match '\n' || '\r' ('\n')? { _visibleToParser = false; }

	rule ML_COMMENT():
		match "/*" =>              { _visibleToParser = false; }
		(
			"/*" nongreedy(ML_COMMENT || .)* "*/"
		)
	rule SL_COMMENT():
		match "//" =>              { _visibleToParser = false; }
		(
			"//" (&!"\\\\" ~NEWLINE_CHAR)* "\\\\"?
		)

	////////////////////////////////////////////////////////////////////////////
	// Numbers
	rule INT():
		is64bit = false
		isFloat = false
		match {
			   '0' ('x' || 'X') HEX_DIGIT_GROUP
			   ('.' HEX_DIGIT_GROUP { Type = :REAL })?
			|| DIGIT_GROUP REAL_FRAC? EXPONENT_SUFFIX?
			|| REAL_FRAC EXPONENT_SUFFIX?
		}
		match { // Suffixes:
			   ('f' | 'F') { isFloat = true; Type = :REAL }
			|| &{ Type == :INT } ('l' | 'L') { is64bit = true }
		)?;
	fragment rule HEX_DIGIT_GROUP() = HEXDIGIT+ ('_' HEXDIGIT+)*
	fragment rule DIGIT_GROUP() = DIGIT (('_' DIGIT DIGIT DIGIT) | DIGIT)*
	fragment rule REVERSE_DIGIT_GROUP() = DIGIT DIGIT DIGIT '_' REVERSE_DIGIT_GROUP | DIGIT+
	fragment rule EXPONENT_SUFFIX() = ('e'|'E') ('+'|'-')? DIGIT_GROUP
	fragment rule REAL_FRAC() = '.' REVERSE_DIGIT_GROUP { Type = :REAL }
	
	////////////////////////////////////////////////////////////////////////////
	// Brackets
	rule LPAREN() = '('
	rule RPAREN() = ')'
	rule LBRACE() = '{'
	rule RBRACE() = '}'
	rule LBRACK() = '[' //('assembly:' { $setType(ASSEMBLY_ATTRIBUTE_BEGIN); })?
	rule RBRACK() = ']'

	////////////////////////////////////////////////////////////////////////////
	// Strings
	rule SQ_STRING():
		// nongreedy must be used together with ?, * or +.
		match {
			   '\'' nongreedy(ESC_SEQ / ~NEWLINE_CHAR)* '\'' 
			|| "'''" nongreedy(.)* "'''"
		}
	rule BQ_STRING():
		match {
			   '`' nongreedy(ESC_SEQ / ~NEWLINE_CHAR)* '`'
			|| "```" nongreedy(.)* "```"
		}
	rule DQ_STRING():
		match {
			'"' nongreedy(ESC_SEQ / ~NEWLINE_CHAR)* '"'
		}
	rule TQ_STRING() = '"""' nongreedy(.)* '"""'
	fragment ESC_SEQ: '\\' ~NEWLINE_CHAR
	
	rule RE_STRING():
		match {
			   ('/' nongreedy(RE_CHAR)+ '/') =>
			   '/' nongreedy(RE_CHAR)+ '/'
			|| "@/" =>
			   "@/" nongreedy(RE_CHAR_EX)+ '/'
		}
	fragment rule RE_CHAR    = RE_ESC / ~(NEWLINE_CHAR | WS_CHAR);
	fragment rule RE_CHAR_EX = RE_ESC / ~NEWLINE_CHAR;
	fragment rule RE_ESC     = '\\' ~NEWLINE_CHAR;

	////////////////////////////////////////////////////////////////////////////
	// Punctuation
	
	rule COLON() = ':' &((WS_CHAR | NEWLINE_CHAR | ';' | '#') | "//" | "/*")
	rule EOS() = ';'
	rule PUNC():
		match {
			(  BASIC_PUNC_CHAR
			|| '/' &!('/'|'*')
			|| '\\' &(WS_CHAR)
			|| ':' &{true} // Predicate &{true} eliminates ambiguity warning
			)+
		}

[OneParser(IToken)] class ParserGenerator(ParserBase):
	expr DummyAlternative:
		||  e(30)
		|/| e(30)
		| e(30)
		/ e(30)
	expr Alternative:
		e(30) ||  e(30)
		e(30) |/| e(30)
		e(30) | e(30)
		e(30) / e(30)
	expr Sequence:
		e(10) e(10)
	expr StrongPred:
		e(20) => e(20)
	expr WeakPred:
		& e(10) e(20)
	expr StrongNegPred:
		! e(20) => e(20)
	expr WeakNegPred:
		& ! e(10) e(20)
	expr RepeatStar:
		e(10) *
	expr RepeatPlus:
		e(10) +
	expr Optional:
		e(10) ?
		BRACKS
	expr CodeBlock:
		BRACES
	expr String:
		SQ_STRING
		DQ_STRING
	expr Item:
		PARENS
		ID
	expr ItemWithPred:
		ID == e(5)
	expr Assignment:
		ID = e(10)
