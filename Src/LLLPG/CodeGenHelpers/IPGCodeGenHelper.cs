using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Diagnostics;
using Loyc.Syntax;
using Loyc.Collections;
using S = Loyc.Syntax.CodeSymbols;
using Loyc.Utilities;

namespace Loyc.LLParserGenerator
{
	/// <summary>
	/// A class that implements this interface will generate small bits of code 
	/// that the parser generator will use. The default implementation is
	/// <see cref="IntStreamCodeGenHelper"/>. To install a new code generator,
	/// set the <see cref="LLParserGenerator.CodeGenHelper"/> property or
	/// supply the generator in the constructor of <see cref="LLParserGenerator"/>.
	/// </summary>
	/// <remarks>Two of these methods (VisitInput and FromCode) are called by the
	/// LLLPG macro. All the others are called by the main engine and its helper
	/// classes in <see cref="LLParserGenerator"/>.</remarks>
	public interface IPGCodeGenHelper
	{
		/// <summary>Returns an empty set of the appropriate type for the kind of 
		/// parser being generated by this code.</summary>
		IPGTerminalSet EmptySet { get; }

		/// <summary>In case the IPGCodeGenHelper is interested, the LLLPG macro 
		/// calls this method on each statement in the body of the macro (as a 
		/// preprocessing step, before LLLPG looks at it). No action is required.</summary>
		/// <returns>a new statement to replace the original statement, or null to 
		/// do nothing.</returns>
		LNode VisitInput(LNode stmt, IMessageSink sink);

		/// <summary>Creates a terminal or sequence predicate from a code expression.</summary>
		/// <param name="expr">A expression provided by the user, such as <c>"a string"</c>,
		/// a <c>Token.Type</c>, or a <c>value..range</c>. <c>expr</c> will not be
		/// a call to the inversion operator #~ (that's handled internally using 
		/// <see cref="IPGTerminalSet.Inverted()"/>). This method also handles the
		/// "any token" input, which is an underscore by convention (_).</param>
		/// <param name="errorMsg">An error message to display. If the method 
		/// returns null, the LLLPG macro shows this as an error; if this method does 
		/// not return null, the message (if provided) is shown as a warning.</param>
		/// <returns>If successful, a terminal predicate; otherwise null.</returns>
		Pred CodeToPred(LNode expr, ref string errorMsg);

		/// <summary>Simplifies the specified set, if possible, so that GenerateTest() 
		/// can generate simpler code for an if-else chain in a prediction tree.</summary>
		/// <param name="set"></param>
		/// <param name="dontcare">A set of terminals that have been ruled out,
		/// i.e. it is already known that the lookahead value is not in this set.</param>
		/// <returns>An optimized set, or this.</returns>
		IPGTerminalSet Optimize(IPGTerminalSet set, IPGTerminalSet dontcare);

		/// <summary>Returns an example of a character in the set, or null if this 
		/// is not a set of characters or if EOF is the only member of the set.</summary>
		/// <remarks>This helps produce error messages in LLLPG.</remarks>
		char? ExampleChar(IPGTerminalSet set);
		/// <summary>Returns an example of an item in the set. If the example is
		/// a character, it should be surrounded by single quotes.</summary>
		/// <remarks>This helps produce error messages in LLLPG.</remarks>
		string Example(IPGTerminalSet set);

		/// <summary>Before the parser generator generates code, it calls this
		/// method.</summary>
		/// <param name="classBody">the body (braced block) of the class where 
		/// the code will be generated, which allows the snippet generator to add 
		/// code at class level when needed.</param>
		/// <param name="sourceFile">the suggested <see cref="ISourceFile"/> to 
		/// assign to generated code snippets.</param>
		void Begin(RWList<LNode> classBody, ISourceFile sourceFile);

		/// <summary>Notifies the snippet generator that code generation is 
		/// starting for a new rule.</summary>
		void BeginRule(Rule rule);

		/// <summary><see cref="LLParserGenerator"/> calls this method to notify
		/// the snippet generator that code generation is complete.</summary>
		void Done();

		/// <summary>Generate code to match any token.</summary>
		/// <returns>Default implementation returns <c>@{ Skip(); }</c>, or 
		/// @{ MatchAny(); } if the result is to be saved.</returns>
		LNode GenerateSkip(bool savingResult);

		/// <summary>Generate code to check an and-predicate during or after prediction, 
		/// e.g. <c>&amp;!{foo}</c> becomes <c>!(foo)</c> during prediction and 
		/// <c>Check(!(foo));</c> afterward.</summary>
		/// <param name="andPred">Predicate for which an expression has already been generated</param>
		/// <param name="code">The expression to be checked</param>
		/// <param name="lookaheadAmt">Current lookahead amount. -1 means 
		/// "prediction is complete, generate a Check() statement".</param>
		/// <remarks>LLLPG substitutes $LI and $LA before it calls this method.</remarks>
		LNode GenerateAndPredCheck(AndPred andPred, LNode code, int lookaheadAmt);

		/// <summary>Generate code to match a set, e.g. 
		/// <c>@{ MatchRange('a', 'z');</c> or <c>@{ MatchExcept('\n', '\r'); }</c>.
		/// If the set is too complex, a declaration for it is created in classBody.</summary>
		LNode GenerateMatch(IPGTerminalSet set_, bool savingResult, bool recognizerMode);

		/// <summary>Generates code to read LA(k).</summary>
		/// <returns>The default implementation returns @(LA(k)).</returns>
		LNode LA(int k);

		/// <summary>Returns the data type of LA(k)</summary>
		/// <returns>The default implementation returns @(int).</returns>
		LNode LAType();

		/// <summary>Generates code for the error branch of prediction.</summary>
		/// <param name="covered">The permitted token set, which the input did not match. 
		/// NOTE: if the input matched but there were and-predicates that did not match,
		/// this parameter will be null (e.g. the input is 'b' in <c>(&amp;{x} 'a' | &amp;{y} 'b')</c>,
		/// but y is false).</param>
		/// <param name="laIndex">Lookahead amount at which the error branch is being created.</param>
		LNode ErrorBranch(IPGTerminalSet covered, int laIndex);

		/// <summary>Returns true if a "switch" statement is the preferable code 
		/// generation technique rather than the default if-else chain</summary>
		/// <param name="branchSets">Non-overlapping terminal sets, one set for each 
		/// branch of the prediction tree.</param>
		/// <param name="casesToInclude">To this set, this method should add the 
		/// indexes of branches for which case labels should be generated, e.g.
		/// adding index 2 means that switch cases should be generated for sets[2].
		/// The caller (<see cref="LLParserGenerator"/>) will create an if-else 
		/// chain for all branches that are not added to casesToInclude, and this 
		/// chain will be passed to <see cref="GenerateSwitch"/>.</param>
		/// <remarks>
		/// Using a switch() statement can be important for performance, since the
		/// compiler may be able to implement a switch statement using as little as
		/// a single branch, unlike an if-else chain which often requires multiple
		/// branches.
		/// <para/>
		/// However, it does not always make sense to use switch(), and when it does 
		/// make sense, it may not be wise or possible to include all cases in the
		/// switch, so this method is needed to make the decision.
		/// <para/>
		/// Consider an example with four branches, each having a character set, 
		/// plus an error branch:
		/// <pre>
		///     Branch 1: '*'|'+'|'-'|'/'|'%'|'^'|'&amp;'|','|'|'
		///     Branch 2: '_'|'$'|'a'..'z'|'A'..'Z'|128..65535
		///     Branch 3: '0'..'9'
		///     Branch 4: ' '|'\t'
		///     Error: anything else
		/// </pre>
		/// In this case, it is impossible (well, quite impractical) to use cases 
		/// for all of Branch 2. The most sensible switch() statement probably looks 
		/// like this:
		/// <pre>
		///     switch(la0) {
		///     case '*': case '+': case '-': case '/': case '%':
		///     case '^': case '&amp;': case ',': case '|':
		///         // branch 1
		///     case '0': case '1': case '2': case '3': case '4': 
		///     case '5': case '6': case '7': case '8': case '9': 
		///         // branch 3
		///     case ' ': case '\t':
		///         // branch 4
		///     default:
		///         if (la0 >= 'A' &amp;&amp; la0 &lt;= 'Z' || la0 >= 'a' &amp;&amp; la0 &lt;= 'z' || la0 >= 128 &amp;&amp; la0 &lt;= 65536)
		///             // branch 2
		///         else
		///             // error
		///     }
		/// </pre>
		/// Please note that given LLLPG's current design, it is not possible to "split" a 
		/// branch. For example, the switch cannot include "case '_': case '$':" and use this
		/// to handle branch 2 (but not the error case), while also handling branch 2 in the
		/// "default" case. Although LLLPG has a mechanism to duplicate branches of an 
		/// <see cref="Alts"/> so that the code for handling an alternative is located at 
		/// two different places in a prediction tree (using 'goto' if necessary), it does 
		/// not have a similar mechanism for arbitrary subtrees of a prediction tree.
		/// <para/>
		/// 'sets' does not include the error branch, if any. If there's no error branch, the
		/// last case should be left out of 'casesToInclude' so that there will be a 
		/// 'default:' case. Note: it should always be the <i>last</i> set that is left
		/// out, because that will be the official default branch (the user can control
		/// which branch is default, hence which one comes last, using the 'default' keyword
		/// in the grammar DSL.)
		/// </remarks>
		bool ShouldGenerateSwitch(IPGTerminalSet[] branchSets, MSet<int> casesToInclude, bool hasErrorBranch);

		/// <summary>Generates a switch statement with the specified branches where
		/// branchCode[i] is the code to run if the input is in the set branchSets[i].</summary>
		/// <param name="casesToInclude">The set chosen by <see cref="ShouldGenerateSwitch"/>.</param>
		/// <param name="defaultBranch">Code to be placed in the default: case (if none, the blank stmt <c>@``;</c>)</param>
		/// <param name="laVar">The lookahead variable being switched on (e.g. la0)</param>
		/// <returns>The generated switch block.</returns>
		LNode GenerateSwitch(IPGTerminalSet[] branchSets, MSet<int> casesToInclude, LNode[] branchCode, LNode defaultBranch, LNode laVar);

		/// <summary>Generates code to test whether the terminal denoted 'laVar' is in the set.</summary>
		LNode GenerateTest(IPGTerminalSet set, LNode laVar);

		/// <summary>Generates the method for a rule, given the method's contents.</summary>
		/// <param name="rule">Rule for which a method is needed.</param>
		/// <param name="methodBody">A list of statements produced by 
		/// LLParserGenerator inside the method.</param>
		/// <returns>A method definition for the rule.</returns>
		/// <remarks>To generate the default method, simply call 
		/// <see cref="Rule.CreateMethod(RVList{LNode})"/>.</remarks>
		LNode CreateRuleMethod(Rule rule, RVList<LNode> methodBody);

		/// <summary>Generates the try-wrapper for a recognizer rule.</summary>
		/// <remarks>
		/// To generate the default method, simply call <c>rule.CreateTryWrapperForRecognizer()</c>.
		/// <para/>
		/// Recognizers consist of two methods: the recognizer itself and the
		/// try-wrapper, if it is needed by the grammar. For example, the 
		/// recognizer version of this rule:
		/// <code>
		///   rule Hello @[ "hi" { _foo++; } ];
		/// </code>
		/// is this pair of methods:
		/// <code>
		///   bool Try_Scan_Hello() {
		///     using (new SavedPosition(this))
		///       return Scan_Hello();
		///   }
		///   bool Scan_Hello() {
		///     if (!TryMatch('h'))
		///       return false;
		///     if (!TryMatch('i'))
		///       return false;
		///     return true;
		///   }
		/// </code>
		/// The <c>Try_*</c> helper method is called from normal rules that use an 
		/// zero-width assertion (<c>&amp;Hello</c>), while the recognizer method 
		/// <c>Scan_*</c> is called from other recognizers that call the rule normally 
		/// (i.e. NOT using an and-predicate). By the way, the LLLPG core removes
		/// actions like <c>_foo++</c> from the recognizer version.
		/// <para/>
		/// </remarks>
		LNode CreateTryWrapperForRecognizer(Rule rule);

		/// <summary>Generates code to call a rule based on <c>rref.Rule.Name</c>
		/// and <c>rref.Params</c>.</summary>
		/// <returns>
		/// For a normal rule call, this method should return 
		/// <c>rref.AutoSaveResult(code)</c> where <c>code</c> is the code to 
		/// invoke the rule.
		/// <para/>
		/// Recognizer mode is normally implemented by calling the recognizer 
		/// version of the rule in an "if" statement: <c>if (!Scan_Foo()) return false;</c>
		/// <para/>
		/// Backtrack mode expects a boolean expression to be returned, normally 
		/// something like <c>Try_Scan_Foo()</c> where the name <c>Try_Is_Foo</c> 
		/// comes from the recognizer's <see cref="Rule.TryWrapperName"/>.
		/// </returns>
		LNode CallRule(RuleRef rref, bool recognizerMode);

		LNode CallTryRecognizer(RuleRef rref, int lookahead);
	}


	/// <summary>Suggested base class for custom code generators. Each derived 
	/// class is typically designed for a different kind of token.</summary>
	/// <remarks>
	/// LLPG comes with two derived classes, <see cref="IntStreamCodeGenHelper"/> 
	/// for parsing input streams of characters or integers, and 
	/// <see cref="GeneralCodeGenHelper"/> for parsing other streams. This class 
	/// contains common code used by both, for example:
	/// - default code snippets such as <c>LA0</c> and <c>LA(n)</c>, the default 
	///   error branch, and switch statements;
	/// - the decision function ShouldGenerateSwitch(); and
	/// - alias handling (alias "foo" = bar)
	/// </remarks>
	public abstract class CodeGenHelperBase : IPGCodeGenHelper
	{
		protected static readonly Symbol _Skip = GSymbol.Get("Skip");
		protected static readonly Symbol _MatchAny = GSymbol.Get("MatchAny");
		protected static readonly Symbol _Match = GSymbol.Get("Match");
		protected static readonly Symbol _MatchExcept = GSymbol.Get("MatchExcept");
		protected static readonly Symbol _MatchRange = GSymbol.Get("MatchRange");
		protected static readonly Symbol _MatchExceptRange = GSymbol.Get("MatchExceptRange");
		protected static readonly Symbol _TryMatch = GSymbol.Get("TryMatch");
		protected static readonly Symbol _TryMatchExcept = GSymbol.Get("TryMatchExcept");
		protected static readonly Symbol _TryMatchRange = GSymbol.Get("TryMatchRange");
		protected static readonly Symbol _TryMatchExceptRange = GSymbol.Get("TryMatchExceptRange");
		protected static readonly Symbol _Check = GSymbol.Get("Check");
		protected static readonly Symbol _underscore = GSymbol.Get("_");

		protected int _setNameCounter = 0;
		protected LNodeFactory F;
		protected RWList<LNode> _classBody;
		protected Rule _currentRule;
		Dictionary<IPGTerminalSet, Symbol> _setDeclNames;
		Dictionary<LNode, LNode> _definedAliases;

		public abstract IPGTerminalSet EmptySet { get; }
		
		public virtual LNode VisitInput(LNode stmt, IMessageSink sink) {
			return null;
		}
		
		public abstract Pred CodeToPred(LNode expr, ref string errorMsg);
		public virtual IPGTerminalSet Optimize(IPGTerminalSet set, IPGTerminalSet dontcare) { return set.Subtract(dontcare); }
		public virtual char? ExampleChar(IPGTerminalSet set) { return null; }
		public abstract string Example(IPGTerminalSet set);

		public virtual void Begin(RWList<LNode> classBody, ISourceFile sourceFile)
		{
			_classBody = classBody;
			F = new LNodeFactory(sourceFile);
			_setDeclNames = new Dictionary<IPGTerminalSet, Symbol>();
		}
		public virtual void BeginRule(Rule rule)
		{
			_currentRule = rule;
			_setNameCounter = 0;
		}
		public virtual void Done()
		{
			_classBody = null;
			F = null;
			_setDeclNames = null;
			_currentRule = null;
		}

		public virtual LNode GenerateTest(IPGTerminalSet set, LNode laVar)
		{
			LNode test = GenerateTest(set, laVar, null);
			if (test == null) {
				var setName = GenerateSetDecl(set);
				test = GenerateTest(set, laVar, setName);
			}
			return test;
		}

		/// <summary>Generates code to test whether a terminal is in the set.</summary>
		/// <param name="subject">Represents the variable to be tested.</param>
		/// <param name="setName">Names an external set variable to use for the test.</param>
		/// <returns>A test expression such as <c>(la0 >= '0' &amp;&amp; '9' >= la0)</c>, or 
		/// null if an external setName is needed and was not provided.</returns>
		/// <remarks>
		/// At first, <see cref="LLParserGenerator"/> calls this method with 
		/// <c>setName == null</c>. If it returns null, it calls the method a
		/// second time, giving the name of an external variable in which the
		/// set is held (see <see cref="GenerateSetDecl(IPGTerminalSet)"/>).
		/// <para/>
		/// For example, if the subject is @(la0), the test for a simple set
		/// like [a-z?] might be something like <c>(la0 >= 'a' &amp;&amp; 'z' >= la0)
		/// || la0 == '?'</c>. When the setName is <c>foo</c>, the test might be 
		/// <c>foo.Contains(la0)</c> instead.
		/// </remarks>
		protected abstract LNode GenerateTest(IPGTerminalSet set, LNode subject, Symbol setName);

		protected virtual Symbol GenerateSetName(Rule currentRule)
		{
			return GSymbol.Get(string.Format("{0}_set{1}", currentRule.Name.Name, _setNameCounter++));
		}

		protected virtual Symbol GenerateSetDecl(IPGTerminalSet set)
		{
			Symbol setName;
			if (_setDeclNames.TryGetValue(set, out setName))
				return setName;

			setName = GenerateSetName(_currentRule);
			_classBody.Add(GenerateSetDecl(set, setName));

			return _setDeclNames[set] = setName;
		}

		/// <summary>Generates a declaration for a variable that holds the set.</summary>
		/// <remarks>
		/// For example, if setName is foo, a set such as [aeiouy] 
		/// might use an external declaration such as 
		/// <code>IntSet foo = IntSet.Parse("[aeiouy]");</code>
		/// This method will not be called if <see cref="GenerateTest(IPGTerminalSet,LNode)"/>
		/// never returns null.
		/// </remarks>
		protected abstract LNode GenerateSetDecl(IPGTerminalSet set, Symbol setName);

		/// <summary>Returns <c>(Skip())</c>, or <c>(MatchAny())</c> if the result 
		/// is to be saved.</summary>
		public virtual LNode GenerateSkip(bool savingResult) // match anything
		{
			if (savingResult && !_currentRule.IsRecognizer)
				return F.Call(_MatchAny);
			else
				return F.Call(_Skip);
		}

		/// <summary>Generate code to check an and-predicate during or after prediction, 
		/// e.g. &amp;!{foo} becomes !(foo) during prediction and Check(!(foo)); afterward.</summary>
		/// <param name="andPred">Predicate for which an expression has already been generated</param>
		/// <param name="code">The expression to be checked</param>
		/// <param name="li">Current lookahead amount. -1 means "prediction is 
		/// complete, generate a Check() statement".</param>
		/// <remarks>LLLPG substitutes $LI and $LA before it calls this method.</remarks>
		public virtual LNode GenerateAndPredCheck(AndPred andPred, LNode code, int li)
		{
			if (andPred.Not)
				code = F.Call(S.Not, code);
			if (li >= 0)
				return code;
			else {
				string asString = (andPred.Pred is LNode 
					? ((LNode)andPred.Pred).Print(NodeStyle.Expression) 
					: andPred.Pred.ToString());
				if (andPred.Not)
					asString = "!(" + asString + ")";
				return F.Call(_Check, code, F.Literal(asString));
			}
		}

		public virtual LNode GenerateMatch(IPGTerminalSet set, bool savingResult, bool recognizerMode)
		{
			LNode call = GenerateMatchExpr(set, savingResult, recognizerMode);
			if (recognizerMode)
				return F.Call(S.If, F.Call(S.Not, call), F.Call(S.Return, F.@false));
			else
				return call;
		}
		/// <summary>Generate code to match a set, e.g. 
		/// <c>@{ MatchRange('a', 'z');</c> or <c>@{ MatchExcept('\n', '\r'); }</c>.
		/// If the set is too complex, a declaration for it is created in classBody.</summary>
		public abstract LNode GenerateMatchExpr(IPGTerminalSet set, bool savingResult, bool recognizerMode);

		protected readonly Symbol _LA = GSymbol.Get("LA");
		protected readonly Symbol _LA0 = GSymbol.Get("LA0");

		/// <summary>Generates code to read LA(k).</summary>
		/// <returns>Default implementation returns LA0 for k==0, LA(k) otherwise.</returns>
		public virtual LNode LA(int k)
		{
			return k == 0 ? F.Id(_LA0) : F.Call(_LA, F.Literal(k));
		}

		/// <summary>Generates code for the default error branch of prediction
		/// (called when there is no explicit error branch).</summary>
		/// <param name="covered">The permitted token set, which the input did not match. 
		/// NOTE: if the input matched but there were and-predicates that did not match,
		/// this parameter will be null (e.g. the input is 'b' in <c>(&amp;{x} 'a' | &amp;{y} 'b')</c>,
		/// but y is false.</param>
		/// <param name="laIndex">Location of unexpected input, relative to current position.</param>
		public virtual LNode ErrorBranch(IPGTerminalSet covered, int laIndex)
		{
			string coveredS = covered.ToString();
			if (coveredS.Length > 45)
				coveredS = coveredS.Substring(0, 40) + "...";
			return F.Call("Error", F.Call(S.Add, F.Id("InputPosition"), F.Literal(laIndex)), 
				F.Literal(string.Format("In rule '{0}', expected one of: {1}", _currentRule.Name.Name, coveredS)));
		}

		/// <summary>Returns the data type of LA(k)</summary>
		/// <returns>Default implementation returns @(int).</returns>
		public abstract LNode LAType();

		/// <summary>Used to help decide whether a "switch" or an if-else chain 
		/// will be used for prediction. This is the starting cost of a switch 
		/// (the starting cost of an if-else chain is set to zero).</summary>
		protected virtual int BaseCostForSwitch { get { return 8; } }
		/// <summary>Used to help decide whether a "switch" or an if statement
		/// will be used to handle a prediction tree, and if so which branches.
		/// This method should calculate the "cost of switch" (which generally 
		/// represents a code size penalty, as there is a separate case for 
		/// every element of the set) and the "cost of if" (which generally 
		/// represents a speed penalty) and return the difference (so that 
		/// positive numbers favor "switch" and negative numbers favor "if".)</summary>
		/// <remarks>If the set is inverted, return a something like -1000000 
		/// to ensure 'switch' is not used for that set.</remarks>
		protected virtual int GetRelativeCostForSwitch(IPGTerminalSet set) { return -1000000; }
		/// <summary>Gets the literals or symbols to use for switch cases of
		/// a set (just the values, not including the case labels.)</summary>
		protected virtual IEnumerable<LNode> GetCases(IPGTerminalSet set) { throw new NotImplementedException(); }

		/// <summary>Decides whether to use a switch() and for which cases, using
		/// <see cref="BaseCostForSwitch"/> and <see cref="GetRelativeCostForSwitch"/>.</summary>
		public virtual bool ShouldGenerateSwitch(IPGTerminalSet[] sets, MSet<int> casesToInclude, bool hasErrorBranch)
		{
			// Compute scores
			IPGTerminalSet covered = EmptySet;
			int[] score = new int[sets.Length - 1]; // no error branch? then last set must be default
			for (int i = 0; i < score.Length; i++) {
				Debug.Assert(sets[i].Subtract(covered).Equals(sets[i]));
				score[i] = GetRelativeCostForSwitch(sets[i]);
			}

			// Consider highest scores first to figure out whether switch is 
			// justified, and which branches should be expressed with "case"s.
			bool should = false;
			int switchScore = -BaseCostForSwitch;
			for (;;) {
				int maxIndex = score.IndexOfMax(), maxScore = score[maxIndex];
				switchScore += maxScore;
				if (switchScore > 0)
					should = true;
				else if (maxScore < 0)
					break;
				casesToInclude.Add(maxIndex);
				score[maxIndex] = -1000000;
			}
			return should;
		}

		public virtual LNode GenerateSwitch(IPGTerminalSet[] branchSets, MSet<int> casesToInclude, LNode[] branchCode, LNode defaultBranch, LNode laVar)
		{
			Debug.Assert(branchSets.Length == branchCode.Length);

			RWList<LNode> stmts = new RWList<LNode>();
			for (int i = 0; i < branchSets.Length; i++) {
				if (casesToInclude.Contains(i)) {
					foreach (LNode value in GetCases(branchSets[i])) {
						stmts.Add(F.Call(S.Case, value));
						if (stmts.Count > 65535) // sanity check
							throw new InvalidOperationException("switch is too large to generate");
					}
					AddSwitchHandler(branchCode[i], stmts);
				}
			}

			if (!defaultBranch.IsIdNamed(S.Missing)) {
				stmts.Add(F.Call(S.Label, F.Id(S.Default)));
				AddSwitchHandler(defaultBranch, stmts);
			}

			return F.Call(S.Switch, (LNode)laVar, F.Braces(stmts.ToRVList()));
		}
		private void AddSwitchHandler(LNode branch, RWList<LNode> stmts)
		{
			stmts.SpliceAdd(branch, S.Splice);
			if (EndMayBeReachable(branch))
				stmts.Add(F.Call(S.Break));
		}

		// Decides whether to add a "break" at the end of a switch case.
		protected virtual bool EndMayBeReachable(LNode stmt)
		{
			// The goal of this code is to avoid the dreaded compiler warning 
			// "Unreachable code detected". We're conservative, to avoid a compiler 
			// error about a missing "break". This is just a heuristic since we 
			// don't have access to proper reachability analysis.
			if (!stmt.HasSpecialName)
				return true;

			if (stmt.Calls(S.Goto, 1))
				return false;
			else if (stmt.Calls(S.Continue) || stmt.Calls(S.Break))
				return false;
			else if (stmt.Calls(S.Return))
				return false;
			else if (stmt.Calls(S.GotoCase, 1))
				return false;
			
			LNode body;
			if (stmt.CallsMin(S.Braces, 1))
				return EndMayBeReachable(stmt.Args.Last);
			else if (stmt.Calls(S.If, 2))
				return EndMayBeReachable(stmt.Args.Last);
			else if (stmt.Calls(S.If, 3)) {
				return EndMayBeReachable(stmt.Args[1])
					|| EndMayBeReachable(stmt.Args[2]);
			} else if (stmt.CallsMin(S.Switch, 2) && (body = stmt.Args[1]).CallsMin(S.Braces, 2)) {
				// for a switch statement, assume it exits normally if a break 
				// statement is the last statement of any of the cases.
				bool beforeCase = true;
				for (int i = body.ArgCount - 1; i > 0; i--) {
					var substmt = body.Args[i];
					if (beforeCase && substmt.Calls(S.Break))
						return true;
					beforeCase = substmt.Calls(S.Case) || substmt.Calls(S.Label, 1) && substmt.Args[0].IsIdNamed(S.Default);
				}
				return false;
			} else if (stmt.Calls(S.For) || stmt.Calls(S.While) || stmt.Calls(S.DoWhile)) {
				return true;
			} else if (stmt.CallsMin(S.Try, 1)) {
				return EndMayBeReachable(stmt.Args[0]);
			} else if (stmt.ArgCount >= 1) {
				Debug.Assert(stmt.HasSpecialName);
				return EndMayBeReachable(stmt.Args.Last);
			}
			return true;
		}

		public virtual LNode CreateRuleMethod(Rule rule, RVList<LNode> methodBody)
		{
			return rule.CreateMethod(methodBody);
		}
		public LNode CreateTryWrapperForRecognizer(Rule rule)
		{
			return rule.CreateTryWrapperForRecognizer();
		}

		public virtual LNode CallRule(RuleRef rref, bool recognizerMode)
		{
			Rule target = rref.Rule;
			if (recognizerMode)
				target = target.MakeRecognizerVersion();
			LNode call = F.Call(target.Name, rref.Params);
			if (recognizerMode)
				return F.Call(S.If, F.Call(S.Not, call), F.Call(S.Return, F.@false));
			else
				return rref.AutoSaveResult(call);
		}

		public virtual LNode CallTryRecognizer(RuleRef rref, int lookahead)
		{
			Rule target = rref.Rule;
			target = target.MakeRecognizerVersion();
			LNode name = target.TryWrapperName;
			var @params = rref.Params;
			return F.Call(name, @params.Insert(0, F.Literal(lookahead)));
		}
	}
}
