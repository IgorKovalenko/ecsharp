using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using Loyc.Syntax;
using Loyc.Utilities;
using Loyc.Collections;
using Loyc.Collections.Impl;
using Loyc.Syntax.Lexing;

namespace Loyc.LLParserGenerator
{
	using TT = TokenType;
	using S = CodeSymbols;

	internal partial class StageOneParser : BaseParser<Token>
	{
		[FullLLk]
		LLLPG(parser(laType(TT), matchType(int), allowSwitch(true)))
		{
			// Operators of LLLPG in order of precedence:
			alias("."   = TT.Dot);
			alias("|,/" = TT.Alt);
			alias(".."  = TT.DotDot);
			alias("~"   = TT.InvertSet);
			alias("+"   = TT.Plus);
			alias("*"   = TT.Star);
			alias("?"   = TT.QMark);
			alias("=>,<=>" = TT.Arrow);
			alias("&"   = TT.And);
			alias("!"   = TT.Not);
			alias("&!"  = TT.AndNot);
			alias(","   = TT.Separator);
			alias("("   = TT.LParen);
			alias(")"   = TT.RParen);
			alias("["   = TT.LBrack);
			alias("]"   = TT.LBrack);
			alias("{"   = TT.LBrace);
			alias("}"   = TT.RBrace);
			
			void Infix(ref LNode a, Symbol op, LNode b) {
				a = F.Call(op, a, b, a.Range.StartIndex, b.Range.EndIndex);
			}

			public rule LNode Parse @[ e:=Expr {return e;} ];
			
			private rule LNode Expr() @[
				a:=GateExpr 
				( op:=("|,/") b:=GateExpr {Infix(ref a, (Symbol) op.Value, b);} )*
				{return a;}
			];
			private rule LNode GateExpr() @[
				a:=SeqExpr
				( op:="=>,<=>" b:=GateExpr {Infix(ref a, (Symbol) op.Value, b);} )?
				{return a;}
			];
			private rule LNode SeqExpr() @[
				{LNode seq = F.Tuple();}
				( next:=LoopExpr {seq = seq.PlusArg(next);} ","? )*
				{return seq;}
			];
			private rule LNode LoopExpr() @[
				{LNode a;}
				(	loopMod:=(TT.Greedy|TT.Nongreedy) a=AssignExpr 
					{a = F.Call((Symbol) loopMod.Value, a, loopMod.StartIndex, a.Range.EndIndex);}
				|	a=AssignExpr
				)
				(	op:="*" {a = F.Call(_SufStar, a, a.Range.StartIndex, op.EndIndex);}
				|	op:="+" {a = F.Call(_SufPlus, a, a.Range.StartIndex, op.EndIndex);}
				|	op:="?" {a = F.Call(_SufOpt,  a, a.Range.StartIndex, op.EndIndex);}
				)?
				{return a;}
			];
			
			private rule LNode AssignExpr() @[
				a:=PrefixExpr
				( op:=(TT.Assignment|TT.HostOperator) b:=AssignExpr {Infix(ref a, (Symbol) op.Value, b);} )?
				{return a;}
			];
			
			private rule LNode PrefixExpr() @
			[	op:="~"       r:=PrefixExpr         {return F.Call(S.NotBits, r, op.StartIndex, r.Range.EndIndex);}
			|	op:=("!"|"&!")r:=PrefixExprOrBraces {return F.Call(_AndNot,   r, op.StartIndex, r.Range.EndIndex);}
			/	op:="&"       r:=PrefixExprOrBraces {return F.Call(S.AndBits, r, op.StartIndex, r.Range.EndIndex);}
			|	r:=RangeExpr  {return r;}
			];
			private rule LNode PrefixExprOrBraces() @
			[	lb:="{" rb:="}" {return ParseBraces(lb, rb.EndIndex, true);}
			/	e:=PrefixExpr   {return e;}
			];
			
			private rule LNode RangeExpr() @[
				a:=PrimaryExpr 
				( op:=".." b:=PrimaryExpr {Infix(ref a, (Symbol) op.Value, b);} )?
				{return a;}
			];
			
			private rule LNode PrimaryExpr() @[
				a:=Atom
				greedy(
					// dotted expr
					op:="." b:=Atom {Infix(ref a, (Symbol)op.Value, b);}
				|	// rule call: no spaces between identifier and '('
					&{a.Range.EndIndex == LT($LI).StartIndex}
					lp:="(" rp:=")"
					{a = F.Call(a, ParseArgList(lp), a.Range.StartIndex, rp.EndIndex);}
				)*
				{return a;}
			];

			// An Atom is:
			// - a prefix operator followed by an Expr
			// - [Attributes] followed by an Atom
			// - an (expression) in parenthesis
			// - a { block } in braces
			private rule LNode Atom() @[
				{LNode e;}
				(	t:=TT.Id
					{e = F.Id(t);}
				|	t:=(TT.Number | TT.String | TT.OtherLit)
					{e = F.Literal(t);}
				|	lp:="(" rp:=")"     {e = ParseParens(lp, rp.EndIndex);}
				|	lb:="{" rb:="}"     {e = ParseBraces(lb, rb.EndIndex, false);}
				|	lb:="[" rb:="]"     
					&("?"|"+"|"*")      {e = ParseParens(lb, rb.EndIndex);}
				|	error {
						e = F.Id(S.Missing, LT0.StartIndex, LT0.StartIndex);
						Error(InputPosition, "LLLPG: Expected an identifier, literal, or expression in parenthesis");
					}
				)
				{return e;}
			];
		}
	}
}
