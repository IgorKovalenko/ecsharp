using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Loyc;
using Loyc.LLParserGenerator;
using Loyc.Collections;
using Loyc.Syntax;
using Loyc.Syntax.Lexing;
using LLLPG;

namespace Loyc.Syntax.Les
{
	[#filePrivate] alias TT = TokenType;
	[#filePrivate] alias S = CodeSymbols;
	[#filePrivate] alias P = LesPrecedence;

	class LesParser { LLLPG parser {
		// An Atom is:
		// - a literal or simple identifier
		//   - simple calls are also handled here, as a space optimization
		// - a token literal
		// - a prefix operator followed by an Expr
		// - [Attributes] followed by an Atom
		// - an (expression) in parenthesis
		// - a { block } in braces
		// - a token literal @[ ... ]
		rule Atom(context::Precedence, [ref] attrs::RWList!LNode)::LNode
		@[
			{LNode e, _;}
			(	t:=TT.Id
				(	&{t.EndIndex == LT($LI).StartIndex && context.CanParse(P.Primary)}
					p:=TT.LParen rp:=TT.RParen
					{e = F.Call((Symbol)t.Value, ExprListInside(p).ToRVList(), t.StartIndex, rp.EndIndex - t.StartIndex);}
				/	{e = F.Id((Symbol)t.Value, t.StartIndex, t.Length);})
			|	t:=(TT.Number|TT.String|TT.SQString|TT.Symbol|TT.OtherLit) 
				{e = F.Literal(t.Value, t.StartIndex, t.Length);}
			|	TT.At t:=TT.LBrack rb:=TT.RBrack
				{e = F.Literal(t.Children, t.StartIndex, rb.EndIndex - t.StartIndex);}
			|	t:=(TT.NormalOp|TT.BQString|TT.Dot|TT.Assignment|TT.PreSufOp|TT.PrefixOp)
				e=Expr(PrefixPrecedenceOf(t), [#out] _) 
				{e = F.Call((Symbol)t.Value, e, t.StartIndex, e.Range.EndIndex - t.StartIndex);}
			|	t:=TT.LBrack TT.RBrack
				{attrs = AppendExprsInside(t, attrs);}
				e=Atom(context, ref attrs)
			|	t:=TT.LParen rp:=TT.RParen {e = InterpretParens(t, rp.EndIndex);}
			|	t:=TT.LBrace rb:=TT.RBrace {e = InterpretBraces(t, rb.EndIndex);}
			|	error {
					e = F.Id(S.Missing, LT0.BeginIndex, 0);
					Error("Expected an expression here");
				}
			)
			{return e;}
		];

		_primaryExpr::LNode;
		
		// Types of expressions:
		// - Atoms (includes attributes and prefix operators)
		// - infix + operators
		// - generic!arguments
		// - suffix_operators++
		// - method_calls(with arguments)
		// - indexers[with indexes]
		[pub] rule Expr(context::Precedence, [out] primary::LNode)::LNode
		@[
			{LNode e; Precedence prec; RVList<LNode> attrs;}
			e=Atom(context, out attrs) 
			{primary = e;}
			greedy
			(	// Infix operator
				&{context.CanParse(prec=InfixPrecedenceOf(LT(\LI)))}
				t:=(TT.NormalOp|TT.BQString|TT.Dot|TT.Assignment)
				rhs:=Expr(prec, [#out] primary)
				{e = F.Call((Symbol)t.Value, e, rhs, e.Range.StartIndex, rhs.Range.EndIndex - e.Range.StartIndex);}
				{e.BaseStyle = NodeStyle.Operator;}
				{if (!prec.CanParse(P.NullDot)) primary = e;}
			|	// ! operator (generics)
				&{context.CanParse(P.Primary)}
				TT.Not
				rhs:=Expr(P.Primary, [#out] primary)
				{
					RVList<LNode> args;
					if (rhs.Calls(S.Missing))
						args = new RVList<LNode>(e).AddRange(rhs.Args);
					else
						args = new RVList<LNode>(e, rhs);
					e = F.Call(S.Of, args, e.Range.StartIndex, rhs.Range.EndIndex - e.Range.StartIndex);
					e.BaseStyle = NodeStyle.Operator;
				}
			|	// Suffix operator
				&{context.CanParse(SuffixPrecedenceOf(LT(\LI)))}
				t:=(TT.PreSufOp|TT.SuffixOp)
				{e = F.Call(ToSuffixOpName((Symbol)t.Value), e, e.Range.StartIndex, t.EndIndex - e.Range.StartIndex);}
				{e.BaseStyle = NodeStyle.Operator;}
				{primary = null;} // disallow superexpression after suffix (prefix/suffix ambiguity)
			|	// Method call
				&{e.Range.EndIndex == LT(\LI).StartIndex && context.CanParse(P.Primary)}
				t:=TT.LParen rp:=TT.RParen
				{e = primary = F.Call(e, ExprListInside(t).ToRVList(), e.Range.StartIndex, rp.EndIndex - e.Range.StartIndex);}
				{e.BaseStyle = NodeStyle.PurePrefixNotation;}
			|	// Indexer / square brackets
				&{context.CanParse(P.Primary)}
				t:=TT.LBrack rb:=TT.RBrack
				{
					var args = new RWList<LNode> { e };
					AppendExprsInside(t, args);
					e = primary = F.Call(S.Bracks, args.ToRVList(), e.Range.StartIndex, rb.EndIndex - e.Range.StartIndex);
					e.BaseStyle = NodeStyle.Expression;
				}
			)*
			{return attrs == null ? e : e.WithAttrs(attrs.ToRVList());}
		];

		// A superexpression is a sequence of expressions with no separator 
		// between them. The first expression is treated specially; e.g.
		// the super expression a+b c*d e=f, which consists of three
		// expressions a+b, c*d and e=f, is parsed (a + b(c * d, e = f)).
		pub SuperExpr()::LNode @[
			{LNode primary, p_;}
			e:=Expr(StartStmt, [#out] primary)
			{var otherExprs = RVList<LNode>.Empty; p_ = e;}
			(	
				{if (p_ == null) Error(InputPosition-2, "Suffix operator is ambiguous at superexpression boundary.");}
				otherExprs+=Expr(StartStmt, [#out] p_) 
				{primary.BaseStyle = NodeStyle.Special;}
			)*
			~(TT.Semicolon | TT.Comma) {  } ~(TT.Semicolon | TT.Comma)*
			{return MakeSuperExpr(e, primary, otherExprs);}
		];

		LNode MissingExpr = F.Id(S.Missing);

		pub SuperExprOpt()::LNode @[
			(e:=SuperExpr {return e;} | {return MissingExpr;})
		];
		// A sequence of expressions separated by commas
		pub ExprList([ref] exprs::RWList!LNode) @[
			{exprs = exprs ?? new RWList<LNode>();}
			(	exprs+=SuperExpr
				(TT.Comma exprs+=SuperExprOpt)*
			|	{exprs.Add(MissingExpr);}
				(TT.Comma exprs+=SuperExprOpt)+
			)?
		];

		pub SuperExprOptUntil(terminator::TokenType)::LNode @[
			{LNode e = MissingExpr;}
			e=SuperExpr?
			{bool error = false;}
			(	&{\LA!=terminator} 
				{	if (!error) {
						error = true;
						Error(InputPosition, "Expected " + terminator.ToString());
					}
				}
				_ 
			)*
			{return e;}
		];
		pub StmtList([ref] exprs::RWList!LNode) @[
			{exprs = exprs ?? new RWList<LNode>();}
			next:=SuperExprOptUntil(TT.Semicolon)
			(	{exprs.Add(next);}
				TT.Semicolon 
				next=SuperExprOptUntil(TT.Semicolon)
			)*
			{if (next != (object)MissingExpr) exprs.Add(next);}
		];
	
	}};
};




