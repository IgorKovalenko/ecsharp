/*
	Oh what fun, I'll finally get to compile a grammar using LLLPG!
	It's taken more than a year to get to this point, how exciting!!!

	OK, the goal: WRITE THE GRAMMAR OF LES IN LES.
*/
import System;
import System.Collections.Generic;
import System.Linq;
import System.Text;
import Loyc;
import Loyc.LLParserGenerator;
import Loyc.Collections;
import Loyc.Syntax;
import Loyc.Syntax.Lexing;

namespace Loyc.Syntax.Les
{
	using TT = TokenType;
	using S = CodeSymbols;
	using P = LesPrecedence;

	public partial class LesParser {
		[FullLLk] LLLPG parser(laType(TT), matchType(int), allowSwitch(@true)) {
			// An Atom is:
			// - a literal or simple identifier
			//   - simple calls are also handled here, as a space optimization
			// - a token literal @[ ... ]
			// - a prefix operator followed by an Expr
			// - [Attributes] followed by an Atom
			// - an (expression) in parenthesis
			// - a { block } in braces
			private rule Atom(contextA::Precedence, ref attrs::RWList!LNode)::LNode @[
				{e::LNode = MissingExpr; _::LNode;}
				(	// identifier or identifier(call)
					t:=TT.Id
					(	&{t.EndIndex == LT($LI).StartIndex && contextA.CanParse(P.Primary)}
						p:=TT.LParen rp:=TT.RParen
						{e = ParseCall(t, p, rp.EndIndex);}
					/	{e = F.Id(t.Value -> Symbol, t.StartIndex, t.Length);}
					)
				|	// literal
					t:=(TT.Number|TT.String|TT.SQString|TT.Symbol|TT.OtherLit) 
					{e = F.Literal(t.Value, t.StartIndex, t.Length);}
				|	// @[Token literal]
					TT.At t:=TT.LBrack rb:=TT.RBrack
					{e = F.Literal(t.Children, t.StartIndex, rb.EndIndex - t.StartIndex);}
				|	// Prefix/suffix operator
					t:=(TT.PrefixOp | TT.PreSufOp)
					e = Expr(PrefixPrecedenceOf(t), out _)
					{e = F.Call(t.Value -> Symbol, e, t.StartIndex, e.Range.EndIndex - t.StartIndex);}
				|	// Prefix/infix operator
					// (the fact that it's called "contextA" rather than "context" is a hack, part of LLLPG support)
					&{contextA != P_SuperExpr}
					t:=(TT.NormalOp|TT.Not|TT.BQString|TT.Dot|TT.Assignment|TT.Colon)
					e=Expr(PrefixPrecedenceOf(t), out _) 
					{e = F.Call(t.Value -> Symbol, e, t.StartIndex, e.Range.EndIndex - t.StartIndex);}
				|	// [Attributes]
					t:=TT.LBrack TT.RBrack
					{attrs = AppendExprsInside(t, attrs);}
					e=Atom(contextA, ref attrs)
				|	// (parens)
					t:=TT.LParen rp:=TT.RParen {e = ParseParens(t, rp.EndIndex);}
				|	// {braces}
					t:=TT.LBrace rb:=TT.RBrace {e = ParseBraces(t, rb.EndIndex);}
				|	error {
						e = F.Id(S.Missing, LT0.StartIndex, 0);
						Error(InputPosition, "Expected an expression here");
					}
				)
				{return e;}
			];
			
			// Types of expressions:
			// - Atoms (includes attributes and prefix operators)
			// - infix + operators
			// - generic!arguments
			// - suffix_operators++
			// - method_calls(with arguments)
			// - indexers[with indexes]
			token Expr(context::Precedence, [out] primary::LNode)::LNode @[
				{e::LNode; _::LNode; prec::Precedence; attrs::RWList!LNode = @null;}
				e=Atom(context, ref attrs) 
				{primary = e;}
				{var contextA = context;} // part of a hack for LLLPG support
				greedy
				(	// Infix operator
					//&{context.CanParse(prec=InfixPrecedenceOf(LT($LI)))}
					{if (!context.CanParse(prec = InfixPrecedenceOf(LT(0)))) { goto end; };}
					t:=(TT.NormalOp|TT.BQString|TT.Dot|TT.Assignment|TT.Colon)
					rhs:=Expr(prec, out primary)
					{e = F.Call(t.Value -> Symbol, e, rhs, e.Range.StartIndex, rhs.Range.EndIndex - e.Range.StartIndex);}
					{e.BaseStyle = NodeStyle.Operator;}
					{if (!prec.CanParse(P.NullDot)) primary = e;}
				|	// ! operator (generics)
					&{context.CanParse(P.Primary)}
					TT.Not
					rhs:=Expr(P.Primary, out primary)
					{
						args::RVList!LNode;
						if (rhs.Calls(S.Tuple)) {
							args = (new RVList!LNode(e)).AddRange(rhs.Args);
						} else {
							i::int = rhs.Attrs.IndexWithName(S.TriviaInParens);
							if (i > -1) rhs = rhs.WithAttrs(rhs.Attrs.RemoveAt(i));
							args = (new RVList!LNode(e, rhs));
						};
						e = primary = F.Call(S.Of, args, e.Range.StartIndex, rhs.Range.EndIndex - e.Range.StartIndex);
						e.BaseStyle = NodeStyle.Operator;
					}
				|	// Suffix operator
					&{context.CanParse(SuffixPrecedenceOf(LT($LI)))}
					t:=(TT.PreSufOp|TT.SuffixOp)
					{e = F.Call(ToSuffixOpName(t.Value -> Symbol), e, e.Range.StartIndex, t.EndIndex - e.Range.StartIndex);}
					{e.BaseStyle = NodeStyle.Operator;}
					{if (t.Type() == TT.PreSufOp) primary = @null;} // disallow superexpression after suffix (prefix/suffix ambiguity)
				|	// Method call
					&{e.Range.EndIndex == LT($LI).StartIndex && context.CanParse(P.Primary)}
					p:=TT.LParen rp:=TT.RParen
					{e = primary = ParseCall(e, p, rp.EndIndex);}
					{e.BaseStyle = NodeStyle.PurePrefixNotation;}
				|	// Indexer / square brackets
					&{context.CanParse(P.Primary)}
					t:=TT.LBrack rb:=TT.RBrack
					{
						var args = (new RWList!LNode { e });
						AppendExprsInside(t, args);
						e = primary = F.Call(S.Bracks, args.ToRVList(), e.Range.StartIndex, rb.EndIndex - e.Range.StartIndex);
						e.BaseStyle = NodeStyle.Expression;
					}
				/	// Juxtaposition / superexpression
					// A loop is not strictly needed here; we could add each expr
					// one at a time, but that would be less efficient in the 
					// majority of cases.
					&{context.CanParse(P_SuperExpr)}
					{var rhs = RVList!LNode.Empty;}
					{contextA = P_SuperExpr;} // hack
					greedy(rhs += Expr(P_SuperExpr, out _))+
					{e = MakeSuperExpr(e, ref primary, rhs);}
				)*
				{label(end); return attrs == @null ? e : e.WithAttrs(attrs.ToRVList());}
			];
			
			// A superexpression is a sequence of expressions with no separator 
			// between them. The first expression is treated specially; e.g.
			// the super expression a+b c*d e=f, which consists of three
			// expressions a+b, c*d and e=f, is parsed (a + b(c * d, e = f)).
			protected rule SuperExpr()::LNode @[
				{_::LNode;}
				e:=Expr(StartStmt, out _)
				{return e;}
			];

			protected rule SuperExprOpt()::LNode @[
				(e:=SuperExpr {return e;} | {return MissingExpr;})
			];
			// A sequence of expressions separated by commas
			protected rule ExprList(ref exprs::RWList!LNode) @[
				{exprs = exprs ?? (new RWList!LNode());}
				(	exprs+=SuperExpr
					(TT.Comma exprs+=SuperExprOpt)*
				|	{exprs.Add(MissingExpr);}
					(TT.Comma exprs+=SuperExprOpt)+
				)?
			];
			
			token SuperExprOptUntil(terminator::TokenType)::LNode @[
				{var e::LNode = MissingExpr;}
				e=SuperExpr?
				{var error::bool = @false;}
				(	(TT.Semicolon|TT.Comma) =>
					greedy(
						&{$LA!=terminator} 
						{	if (!error) {
								error = @true;
								Error(InputPosition, "Expected " + terminator.ToString());
							}
						}
						_ 
					)*
				)
				{return e;}
			];
			public rule StmtList(ref exprs::RWList!LNode) @[
				{exprs = exprs ?? new RWList!LNode();}
				next:=SuperExprOptUntil(TT.Semicolon)
				(	{exprs.Add(next);}
					TT.Semicolon 
					next=SuperExprOptUntil(TT.Semicolon)
				)*
				{if (next != MissingExpr->object) exprs.Add(next);}
			];
		}
	}
}
