import System;
import System.Collections.Generic;
import System.Linq;
import System.Text;
import Loyc;
import Loyc.Syntax;
import Loyc.Syntax.Les;
import Loyc.Syntax.Lexing;
import Loyc.Collections;
import Loyc.Collections.Impl;

namespace Ecs.Parser
{
	using TT = TokenType;
	using S = CodeSymbols;
	using P = EcsPrecedence;

	partial class EcsParser {
	[DefaultK(3)]
	LLLPG parser(laType(TokenType), matchType(int), allowSwitch(@true))
	{
/*
			WORD ATTRIBUTES ALLOWED:
			- On statements that start with keywords (except 'if')
			- On variable declarations, property declarations, and method declarations
*/
		alias("(" = TT.LParen);
		alias(")" = TT.RParen);
		alias("[" = TT.LBrack);
		alias("]" = TT.RBrack);
		alias("{" = TT.LBrace);
		alias("}" = TT.RBrace);
		alias("." = TT.Dot);
		alias("->" = TT.PtrArrow);
		alias("::" = TT.ColonColon);
		alias("?." = TT.NullDot);
		alias("=" = TT.Set);
		alias("??=" = TT.CompoundSet);
		alias(":" = TT.Colon);
		alias("@" = TT.At);
		alias("``" = TT.BQString);
		alias("\\" = TT.Backslash);
		alias("*" = TT.Mul);
		alias("/,%" = TT.Div);
		alias("**" = TT.Power);
		alias("+" = TT.Add);
		alias("-" = TT.Sub);
		alias("++,--" = TT.IncDec);
		alias("&&,||" = TT.AndOr);
		alias("!" = TT.Not);
		alias("&" = TT.AndBits);
		alias("|,^" = TT.OrXorBits);
		alias("~" = TT.NotBits);
		alias("==,!=" = TT.EqNeq);
		alias("<" = TT.LT);
		alias(">" = TT.GT);
		alias("<=,>=" = TT.LEGE);
		alias(".." = TT.DotDot);
		alias("?" = TT.QuestionMark);
		alias("??" = TT.NullCoalesce);
		alias("=:" = TT.QuickBind);
		alias("==>" = TT.Forward);
		alias("$" = TT.Substitute);
		alias("=>" = TT.LambdaArrow);
		alias("," = TT.Comma);
		alias(";" = TT.Semicolon);

		def CallBinary(op::Symbol, lhs::LNode, rhs::LNode)::LNode
		{
			start::int = lhs.Range.StartIndex;
			return F.Call(op, lhs, rhs, start, rhs.Range.EndIndex - start);
		};

		// - class
		// - method
		// - property
		// - variable decl
			
		static readonly _alias::Symbol = GSymbol.Get("alias");
		static readonly _where::Symbol = GSymbol.Get("where");

		private rule WhereClause @[
			// TODO
			&{Is($LI,_where)} TT.Id
		];
			
		def Is(li::int, value::Symbol)::bool
		{
			return LT(li).Value == value;
		};
			
		// Used to resolve the constructor ambiguity, in which "Foo()" could be a
		// constructor declaration or a method call. _spaceName is the name of the
		// current space, or #def (S.Def) when inside a method.
		_spaceName::Symbol;
		
		// ---------------------------------------------------------------------
		// -- Complex identifiers and type names -------------------------------
		// ---------------------------------------------------------------------

		// The complex identifier in EC# is a subset of the language of expressions,
		// and data types are a superset of the language of complex identifiers.
		// Complex identifiers can appear in the following contexts:
		// - Space names: namespace Foo.Bar<$T> {...}
		//   (and yes, I want to support template parameters on namespaces someday)
		// - Method/property names: bool global::System.IEquatable<T>.Equals(T other)
		// Data types can appear in the following contexts:
		// - Fields and properties: int* x { get; set; }
		// - Methods declarations: int[] f(Foo<T>[,][] x);
		// - Certain pseudo-functions: typeof(Foo<T[]>)
		// Note that complex identifiers can contain substitution expressions,
		// which, in turn, can contain expressions of any complexity, e.g. 
		// Foo<$(x*y(++z))>. Of course, complex identifiers also appear within 
		// normal expressions, but the expression grammar doesn't use the
		// main "ComplexId" rule, instead it's handled somewhat separately.

		rule DataType::LNode @[
			e:=ComplexId
			TypeSuffixOpt(ref e)
			{return e;}
		];

		token ComplexId::LNode @[
			e:=IdAtom 
			// There can be only a single "externAlias::" prefix in a complex Id.
			(	"::" e2:=IdAtom 
				{e = CallBinary(S.ColonColon, e, e2);}
			)?
			RestOfId(ref e)
			{return e;}
		];
			
		// identifier, $identifier, $(expr), or primitive type (int, string)
		rule IdAtom::LNode @[
			{r::LNode;}
			( t:="$" r=Expr(P.Substitute, 0) {r=AutoRemoveParens(r);}
			  r = F.Call(S.Substitute, e, t.StartIndex, e.Range.EndIndex - t.StartIndex);}
			| t:=(TT.Id|TT.TypeKeyword)
				{r = F.Id(t.Value -> Symbol, t.StartIndex, t.Length);}
			) {return r;}
		];

		def AutoRemoveParens(node::LNode)::LNode
		{
			i::int = r.Attrs.IndexWithName(S.TriviaInParens);
			if (i > -1)
				rhs = rhs.WithAttrs(rhs.Attrs.RemoveAt(i));
		}

		[recognizer(def Scan_RestOfId())]
		rule RestOfId(ref r::LNode) @[
			TParams(ref r)?
			DotRestOfId(ref r)?
		];

		[recognizer(def Scan_DotRestOfId())]
		rule DotRestOfId(ref r::LNode)
		@[
			"." e:=IdAtom {r=F.Dot(r, e)}
			RestOfId(ref r)
		];

		[recognizer(def Scan_TParams())]
		rule TParams(ref r::LNode)
		@[
			{list::RWList!LNode = (new RWList!LNode());}
			{end::Token;}
			( "<" (list+=ComplexId ("," list+=ComplexId)*)? end=">"
			| "." t:="[" end="]" {list = AppendExprsInside(t, list);}
			| "!" t:="(" end=")" {list = AppendExprsInside(t, list);}
			)
			{
				list.Insert(0, r);
				start::int = r.Range.StartIndex;
				r = F.Call(S.Of, list.ToRVList(), start, end.EndIndex - start);
			}
		];

		count::int; // hack allows Scan_TypeSuffixOpt() to compile

		[recognizer(def Scan_TypeSuffixOpt())]
		rule TypeSuffixOpt(ref e::LNode)::bool
		@[
			{count::int; result::bool = false;}
			(	"?" {e = F.Of(F.Id(S.QuestionMark), e); result=true;}
			|	"*" {e = F.Of(F.Id(S._Pointer), e);     result=true;}
			|	// int[][,] means "array of (two-dimensional array of int)", so we
				// must process array adornments in reverse order.
				{var dims = InternalList!int.Empty;}
				(greedy(&{(count=CountDims(LT($LI))) > 0} "[" "]" {dims.Add(count);}))+
				{
					for (i::int = dims.Count - 1, i >= 0, i--)
						e = F.Of(F.Id(S.GetArrayKeyword(dims[i])), e);
					result = true;
				}
			)*
			{return result;}
		];

		// ---------------------------------------------------------------------
		// -- Attributes -------------------------------------------------------
		// ---------------------------------------------------------------------
		
		// NOTE TO SELF: DO NOT HANDLE "new" AS AN ATTRIBUTE YET!
		_attrs::RWList!LNode = new RWList<LNode>();
		int _wordAttrCount = 0;
			
		rule NormalAttributes @[
			{_attrs.Clear();}
			(	t:="[" "]" {AppendExprsInside(t, _attrs);} )*
			greedy(t:=TT.AttrKeyword {_attrs.Add(F.Id((Symbol)t.Value, t.StartIndex, t.Length));})*
		];
			
		// "word attributes" are a messy feature of EC#. C# has a few non-
		// keyword attributes that appear at the beginning of a statement, such
		// as "partial", "yield" and "async". EC# generalizes this concept to 
		// "word attributes", which can be any normal identifier.
		//
		// BTW: "word attributes" are not really "contextual keywords" in the C# 
		// sense, because the identifiers are not recognized by the parser. The
		// only true contextual keywords in EC# are "var", "module" and "assembly"
		// ("var" is not a contextual keyword in C# in the same way; in EC#, 
		// "var" is identified as a keyword by the parser, but in C# it is 
		// identified during semantic analysis.)
		//
		// Since they're not keywords, word attributes are difficult because:
		// 1. Lots of statements start with words that are not word attributes, 
		//    such as "foo=0", "foo* x = null", "foo x { ... }", and "foo x();"
		//    Somehow we have to figure out which words are attributes.
		// 2. Not all statements accept word attributes. But the attributes 
		//    appear before the statement, so how can we tell if we should
		//    be expecting word attributes or not?
		// Using an LL(k) parser generator is quite limiting in this situation;
		// normal lookahead is strictly limited and we can't backtrack except 
		// via "and" predicates or custom code. On the other hand, I still think 
		// LL(k) is the best way to parse, precisely because it minimizes 
		// backtracking. So I've used and-predicates here to explicitly look 
		// ahead, and I only look ahead far enough to figure out "is this word 
		// an attribute?", not "what kind of statement is this?"
		// 
		// There are lots of "keyword-based" statements that accept word
		// attributes (think "partial class" and "yield return"), which are easy
		// to handle. Our main difficulty is the non-keyword statements:
		// 1. statements that can begin with an identifier, but also accept
		//    word attributes:
		//    - word type* name ... // field, property or method
		//    - word type? name ... // field, property or method
		//    - word type[,][] name ... // field, property or method
		//    - word type<x> name ... // field, property or method
		//    - word type name(); // method decl
		//    - word type name<x>(); // method decl
		//    - word type<x> name(); // method decl
		//    - word type<x> name<x>(); // method decl
		//    - word this();         // except inside methods
		//    - word this<x>();      // except inside methods
		//    - word label:
		// 2. statements that can start with an identifier, and do not accept 
		//    word attributes:
		//    - foo(0);
		//    - foo<x>();
		//    - foo = 0;
		//    - foo - bar;
		// Notice that if a word is followed by an operator of any kind, it 
		// can't be an attribute; but if it is followed by another word, it's
		// unclear. In particular, notice that for "A B<x>...", "A" is sometimes
		// an attribute and sometimes not. In "A B<x> C", A is an attribute,
		// but in "A B<x>()" it is a return type. The same difficulty exists
		// in case of alternate generics specifiers such as "A B!(x)" and types
		// with suffixes, like "A int?*".
		token WordAttributes()::int
		@[
			{int count = 0;}
			(	t:=TT.AttrKeyword {_attrs.Add(F.Id((Symbol)t.Value, t.StartIndex, t.Length));}
			|	&!{!LT($LI).Value.ToString().StartsWith("#")} 
				t:=(TT.Id|TT.@new)
				&(	TypeName TT.Id
				|	&{_spaceName!=S.Def} "this"
				|	TT.@checked "{" "}" | TT.@unchecked "{" "}" | TT.@default ":"
				|	( TT.@namespace | TT.@class | TT.@struct | TT.@interface | TT.@enum 
					| TT.@delegate | TT.@event | TT.@case | TT.@break | TT.@continue | TT.@do 
					| TT.@fixed | TT.@for | TT.@foreach | TT.@goto | TT.@lock | TT.@return 
					| TT.@switch | TT.@throw | TT.@try | TT.@using | TT.@while )
				)
				{count++;}
				{_attrs.Add(F.Id("#" + t.Value.ToString(), t.StartIndex, t.Length));}
			)
			{return count;}
		];
			
		public static readonly _assembly::Symbol = GSymbol.Get("assembly");
		public static readonly _module  ::Symbol = GSymbol.Get("module");
		
		[recognizer(def Scan_AsmOrModLabel())]
		rule AsmOrModLabel @[
			&{LT($LI).Value==_assembly || LT($LI).Value==_module} TT.Id ":"
		];

		/*
		rule AssemblyOrModuleAttribute::RWList!LNode
		@[
			&{Down($LI) && Up(Try_Scan_AsmOrModLabel())} t:="[" "]"
			(() => {Down(t);} AsmOrModLabel L:=ExprList {Up();})
			{return L;}
		];
		*/
		
		// ---------------------------------------------------------------------
		// -- Expressions ------------------------------------------------------
		// ---------------------------------------------------------------------

		// Parsing EC# expressions is very tricky. Here are some of the things 
		// that make it difficult, especially in an LL(k) parser:
		//    
		// 1. Parenthesis: is it a cast or a normal expression?
		//    (A<B,C>)y      is a cast
		//    (A<B,C>)-y     is NOT a cast
		//    (A<B,C>)(-y)   is a cast
		//    (A<B,C>)(as B) is NOT a cast (well, the second part is)
		//    x(A<B,C>)(-y)  is NOT a cast
		//    -(A<B,C>)(-y)  is a cast
		//    $(A<B,C>)(-y)  is NOT a cast
		//    (A<B,C>){y}    is a cast
		//    (A<B,C>)[y]    is NOT a cast
		//    (A<B,C>)++(y)  is NOT a cast (it's post-increment and call)
		//    (A<B> C)(-y)   is NOT a cast
		//    ([] A<B,C>)(y) is NOT a cast (empty attr list defeats cast)
		//    (A+B==C)y      is nonsensical
		//    x(A<B,C>)y     is nonsensical
		// 2. In-expr var declarations: is "(A<B,C>D)" a variable declaration?
		//    (A<B,C>D) => D.Foo() // variable declaration
		//    (A<B,C>D) = Foo()    // variable declaration
		//    (f1, f2) = (A<B,C>D) // tuple
		//    Foo(A<B,C>D)         // method with two arguments
		//    void Foo(A<B,C>D)    // variable declaration at statement level
		//    Foo(A<B,C>D)         // variable declaration at statement level if 'Foo' is the space name
		//                         // (i.e. when 'Foo' is a constructor)
		// 3. Less-than: is it a generics list or an operator? Need unlimited lookahead.
		//    (A<B,C)    // less-than operator
		//    (A<B,C>)   // generics list
		//    (A<B,C>D)  // context-dependent
		// 4. Brackets. Is "Foo[]" a data type, or an indexer with no args?
		//    (Foo[]) x; // data type: #of(#[], Foo)
		//    (Foo[]).x; // indexer:   #[](Foo)
		// 5. Does "?" make a nullable type or a conditional operator?
		//    Foo<B> ? x = null;     // nullable type
		//    Foo<B> ? x = null : y; // conditional operator
		
		// The Ambiguity flags help communicate contextual nuances between the 
		// rules, to distinguish some of the above cases.
		[Flags]
		enum Ambiguity { 
			// Inputs
			AllowUnassignedVarDecl = 1
			StatementLevel = 2,
			StopAtArgumentList = 8, // helps parse method declaration
			ExpectCast = 4,         // used in (...)x
			ExpectType = 8,         // used in typeof(...)

			// Outputs
			BlankIndexed = 0x0040,
			TypeSuffix = 0x0080,
			IsExpr = 0x0100,        // implies "not a type"
			IsCall = 0x0200,        // implies "not a type"
			HasAttrs = 0x0400,    // defeats cast
			IsTuple = 0x0800,     // multiple arguments (or no arguments)
			Error = 0x1000
			NotAType = IsExpr|IsCall,
				
			Type = BlankIndexed | TypeSuffix,
		}

		static readonly int MinPrec = Precedence.MinValue.Lo;
		/// Context: beginning of statement (#namedArg not supported, allow multiple #var decl)
		public static readonly StartStmt::Precedence    = new Precedence(MinPrec, MinPrec, MinPrec);
		/// Context: beginning of expression (#var must have initial value)
		public static readonly StartExpr::Precedence    = new Precedence(MinPrec+1, MinPrec+1, MinPrec+1);
		/// Context: middle of expression, top level (#var and #namedArg not supported)
		public static readonly ContinueExpr::Precedence = new Precedence(MinPrec+2, MinPrec+2, MinPrec+2);

		// Types of expressions:
		// - identifier
		// - (parenthesized expr)
		// - (tuple,)
		// - ++prefix_operators
		// - suffix_operators++
		// - infix + operators, including x => y
		// - the ? conditional : operator
		// - generic<arguments>
		// - (old_style) casts
		// - call_style(->casts)
		// - method_calls(with, arguments)
		// - typeof(and other pseudofunctions)
		// - indexers[with, indexes]
		// - new Object()
		// - { code in braces; new scope }
		// - #{ code in braces; old scope }
		// - delegate(...) {...}
		// 
		// Note that if we encounter two
		rule Expr(context::Precedence, ref f::Ambiguity)
		@[
			(&{context.CanParse(ContinueExpr)} NormalAttributes)?
			Atom(context, ref f)
			
		];

		
		// Combines the previous precedence floor with that of a prefix operator
		Precedence RP(Precedence prev, Precedence pre) {
			return new Precedence(prev.Lo, prev.Hi, prev.Left, Math.Max(prev.Right, pre.Right));
		}
			
		// An Atom is:
		// - a literal or simple identifier
		//   - simple calls are also handled here, as a space optimization
		// - a token literal @[ ... ]
		// - a prefix operator followed by an Expr
		// - an (expression) in parenthesis
		// - a { block } in braces
		rule Atom(Precedence p, ref Ambiguity f)
		@[
			(	t:=$Id                   {r = F.Id((Symbol)t.Value);}
			|	default t:=$TypeKeyword {r = F.Id((t.Value as Symbol) ?? F._Missing);}
				&{p.CanParse(EP.Prefix)}
				t:=('-'|'+'|'~'|'!'|"++"|"--"|'&'|'*')
				e:=Expr(RP(p, EP.Prefix), ref f)
				{
					r = F.Call((Symbol)t.Value, e);
					f |= Ambiguity.IsExpr;
				}
//			|	// TODO: consider converting "==>" to a binary operator
//				&{p.CanParse(EP.Forward)}
//				"==>"
//				e:=Expr(RP(p, EP.Forward), ref f)
//				{
//					r = F.Call(S.Forward, e);
//					f |= Ambiguity.IsExpr;
//				}
			|  "$"
				e:=Expr(EP.Substitute, ref f)
				{r = F.Call(S.Substitute, e.IsParenthesizedExpr ? e.Args[0] : e);}
			|  t:=('.'|"::")
				e:=Expr(EP.Substitute, ref f)
				{r = F.Call((Symbol)t.Value, e);}
			|	r=NewExpr
			|	r=CastOrParens(p)
			)
		];
			
		NewExpr ==> @[ 
			{LNode r; Ambiguity f = 0;}
			"new" 
				
			typeAndCons:=Expr(EP.Primary, ref f);
			{                     
				if ((f & Ambiguity.NotAType) != 0)
					Error(typeAndCons, "Type expected after 'new'");
				return 
			}
			(	t:="{}"
				{
					var list = ExprListInside(t);
					list.Insert(0, typeAndCons);
					r = F.Call(S.New, list.ToRVList());
				}
			|	{r = F.Call(S.New, typeAndCons);}
			{return r;}
		];
			
		CastOrParens(Parecedence p) ==> @[
			// A cast requires...
			// - Precedence floor of Prefix or lower
			// - Must be followed by $Id, a literal, "{}", $Id, '\\', 
			//   or a "()" that is not one of the new cast operators
			// - That the initial parens are a data type
			// - That the initial parens are not an argument list 
			//   (if so this rule is not called in the first place)
			{LNode r; Ambiguity f;}
			(	&{p.CanParse(EP.Prefix)}
				t:="()"
				&('\\'|$Id|$SQString|$DQString|$Number|"{}" | &!{IsNewCastOp(\LI)} "()")
				{r = ExprOrTupleInside(t, ref f, false);}
				(	=>	// Block further lookahead
					(	// We still don't know if it's a cast until this part runs
						&{(f & (Ambiguity.NotAType|Ambiguity.HasAttrs|Ambiguity.Tuple)) == 0}
						{f = 0;}
						subject:=Expr(RP(p, EP.Prefix), ref f)
						{
							if ((f & Ambiguity.TypeSuffix) != 0)
								Error(subject, "Syntax error: data type not expected here");
							r = F.Call(S.Cast, subject, r);
						}
					|	{	// not a cast
							if ((f & Ambiguity.Tuple) == 0)
								r = F.InParens(r);
						}
					)
				)
			/	t:="()" &('=' | "=>")
				{f = Ambiguity.AllowUnassignedVarDecl;}
				{r = ExprOrTupleInside(t, ref f, true);}
			/	t:="()"
				{f = 0;}
				{r = ExprOrTupleInside(t, ref f, true);}
			)	{return r;}
		];

		LNode ExprOrTupleInside(Token t, ref Ambiguity f, bool saveParensIfNotTuple)
		{
			var c = t.Children;
			Debug.Assert(c != null); // "()", "[]" and "{}" always have children
			if (c.Count == 0) {
				f.Tuple = true;
				return F.@void; // "()" is the void literal
			}
			Down(t);
			f = Ambiguity.ExpectCast;
			r = Up(ExprOrTuple(StartExpr, f));
			if (saveParensIfNotTuple && (f & Ambiguity.Tuple) == 0)
				r = F.InParens(r);
			return r;
		}

		LNode ExprOrTuple(ref Ambiguity f) ==> @[
			first:=Expr(StartExpr, ref f);
			(	{Ambiguity f0 = f; RWList<LNode> list = null; LNode next;}
				(	',' 
					{f=f0;}
					(	next=Expr(StartExpr, ref f)
					|	{next=F._Missing;}
					)
					{
						list = list ?? new RWList<LNode> {first};
						list.Add(next);
						f |= Ambiguity.Tuple;
					}
				)*   {return F.Call(S.Tuple, list.ToRVList());}
			/	_ => {return r;}
			)
		];
			
		bool IsNewCastOp(int li)
		{
			var c = LT(li).Children;
			if (c != null && c.Count != 0)
				return IsNewCastOp(c[0].Type);
		}
		bool IsNewCastOp(TT tt)
		{
			return tt == TT.@is || tt == TT.@as || tt == TT.@using || tt == TT.PtrArrow;
		}
		
		// ---------------------------------------------------------------------
		// -- Statements -------------------------------------------------------
		// ---------------------------------------------------------------------
		
		// Ids at beginning of a Stmt
		List<Triplet<int, LNode, bool>> _startingIds = new List<Triplet<int, LNode, bool>>();
			
		// Parsing C# statements, and by extension EC#, can be a messy business.
		// But I think I've figured out how to parse it efficiently with the 
		// humble LLLPG. The challenge is that:
		// - Lots of statements can start with an arbitrary number of "word 
		//   attributes" which are identifiers that are not keywords or data types.
		// - Methods, properties and variables all start with a pair of complex
		//   identifiers, e.g. a statement that starts with "Foo<T> IList<T>.Count"
		//   could be a method or property depending on what comes next.
		// - Variable/method syntax and expression syntax can be indistinguishable, 
		//   e.g. a * b(); looks like both a multiplication and a method declaration.
		//   (for this kind of ambiguity, the code is always assumed to be a 
		//   declaration rather than an expression.)
		// Obviously, it is impossible to use a simple list of alternatives like
		// "MethodStmt | PropertyStmt | VarStmt", since distinguishing between 
		// these three things requires unlimited lookahead, even if there are no
		// word attributes.
		//
		// The following statement types can use word attributes:
		// - Methods: partial void Main()
		// - Vars:    partial int x;
		// - Spaces:  partial class Foo {}
		// - partial alias x = 5;
		Stmt ==> @[
			(	AssemblyOrModuleAttribute
			|	NormalAttributes
					
				// Gather up all the complex identifiers at the beginning of the 
				// statement into a list.
				firstComplex:=GatherStartingIds
				{var list = _startingIds;}
				{int c = list.Count, i;}
					
				// Once we're past those pesky identifiers, we can easily 
				// distinguish between the types of statements.
				{LNode r;}
				(	&(firstComplex==-1) r=EventDecl
				|	&(firstComplex==-1) r=DelegateDecl
				|	&(firstComplex==-1) r=SpaceDecl
				|	&{c>=2}             r=FinishNonKeywordSpaceDecl
				/	&{c>=2}             r=FinishVarDecl
				|	&{c>=2}             r=FinishPropertyDecl
				|	&{c>=2}             r=FinishMethodDecl
				/* |	LabelStmt // includes default:
				|	BreakStmt
				|	CaseStmt
				|	CheckedStmt
				|	ContinueStmt
				|	DoStmt
				|	EventStmt
				|	FixedStmt
				|	ForStmt
				|	ForEachStmt
				|	GotoStmt
				|	&{nWords==0} IfStmt
				|	LockStmt
				|	ReturnStmt
				|	SwitchStmt
				|	ThrowStmt
				|	TryStmt
				|	UncheckedStmt
				|	UsingStmt
				|	WhileStmt */
				|	&{c<2}              r=FinishExprStmt()
				)
			)
		];
			
		bool GatherStartingIds ==> @[
			{_startingIds.Clear();}
			{bool firstComplex = -1;}
			(
				(	// If we see an attribute keyword (e.g. 'static') after some 
					// identifiers, those identifiers must have been attributes.
					t:=$AttrKeyword 
					{
						if (firstComplex != -1) {
							// maybe user forgot a semicolon?
							Error("Syntax error: attribute keyword '{0}' is unexpected here", 
								t.Value.ToString().Substring(1));
						} else {
							foreach (var triplet in _startingIds)
								_attrs.Add(F.Id((Symbol)triplet.Item2.Value));
						}
						_startingIds.Clear();
					}
				|	{int startPos = _inputPosition;}
					id:=ComplexId
					hasSuf:=TypeSuffixOpt(ref id)
					{
						int len = _inputPosition - startPos;
						if (len > 1 && firstComplex == -1)
							firstComplex = _startingIds.Count;
						_startingIds.Add(Pair.Create(len, id, hasSuf));
					}
				)
			)*
			{return firstComplex;}
		];
			
		int FlushIds(int leftOver)
		{
			int c = _startingIds.Count, attrs = c - leftOver;
			Debug.Assert(c >= leftOver);
			if (attrs > 0) {
				bool error = false;
				for (int i = 0; i < attrs; i++) {
					var triplet = _startingIds[i];
					if (triplet.B.IsIdent) {
						_attrs.Add(F.Id("#" + triplet.B.Name.ToString()));
					} else if (!error) {
						error = true;
						Error(triplet.A, "Syntax error: too many complex identifiers in a row.");
					}
				}
				_startingIds.RemoveRange(0, attrs);
			}
		}
			
		LNode EventDecl ==> @[
			t:="event" {FlushIds(0);}
			GatherStartingIds
			(	&{_startingIds.Count>=2} r:=FinishPropertyDecl(true) {return r;}
			|	{return Error(t, "Syntax error: 'event' is missing data type or name afterward");}
			)
		];
		LNode DelegateDecl ==> @[
			t:="delegate" {FlushIds(0);}
			GatherStartingIds
			(	&{_startingIds.Count>=2} r:=FinishMethodDecl(true) {return r;}
			|	{return Error(t, "Syntax error: 'delegate' is missing data type or name afterward");}
			)
		];
		static readonly Symbol _where = GSymbol.Get("where");
		LNode SpaceDecl ==> @[
			{FlushIds(0);}
			{Token t;}
			(t="namespace" | t="class" | t="struct" | t="interface" | t="enum")
			{Symbol kind = (Symbol)t.Value;}
			name:=ComplexId
			bases:=BaseListOpt
			WhereClausesOpt(ref name)
			(	';'               {return F.Call(kind, name, bases);}
			|	body:=BracedBlock {return F.Call(kind, name, bases, body);}
			)
			&{} $Id
		];
		LNode BaseListOpt ==> @[
			{RWList<LNode> bases = null;}
			(	':' @base:=DataType {bases ??= new RWList<LNode>(); bases.Add(@base);}
				(',' bases+=DataType {bases.Add(@base);})*
			)?
			{return bases == null ? F.EmptyList : F.List(bases.ToRVList());}
		];
		static readonly Symbol _trait = GSymbol.Get("trait");
		static readonly Symbol _alias = GSymbol.Get("alias");
		static readonly Symbol __trait = GSymbol.Get("#trait");
		static readonly Symbol __alias = GSymbol.Get("#alias");
		LNode FinishNonKeywordSpaceDecl ==> @[
			{int i;}
			&{(i=NonKeywordSpaceDeclKeywordIndex()) != -1}
			=> (
				{	// Backtrack if necessary, then flush word attrs
					int c = _startingIds.Count;
					if (i + 2 < c) {
						_inputPosition = _startingIds[i+2].A;
						_startingIds.Resize(i+2);
					}
					FlushIds(2);
					Symbol kind = _startingIds[0].B.Name; // _trait or _alias
					Symbol kind2 = (kind == _trait ? __trait : __alias);
				}
				{LNode name;}
				(	&{kind==_alias} =>
					name=FinishExprStmt()
				|	{Debug.Assert(_kind==_trait);}
					name=_startingIds[1].B;
				)
				bases:=BaseListOpt
				WhereClausesOpt(ref name)
				(	';'               {return F.Call(kind2, name, bases);}
				|	body:=BracedBlock {return F.Call(kind2, name, bases, body);}
				)
			)
		];
		LNode BracedBlock ==> @[
			t:="{}" (=>
				{Down(t);} 
				list:=Stmts 
				{Up(); return F.Braces(list.ToRVList());}
			)
		];
			
		void WhereClausesOpt(ref LNode name) ==> @[
			// TODO: add 'where' clauses to type name
		];
		int NonKeywordSpaceDeclKeywordIndex()
		{
			// Non-space decls like "partial trait X {...}" will normally have 
			// the word 'trait' or 'alias' as the second-to-last word in 
			// _startingIds. However, in the case of "trait X<T> where T : class",
			// the word 'trait' comes earlier. This method figures that out.
			LNode id;
			Symbol name;
			for (int i = 0, c = _startingIds.Count - 1; i < c; i++)
				if ((id = _startingIds[0].B).IsIdent && 
					((name = id.Name) == _trait || name == _alias)
					return i;
			return -1;
		}
			
		LNode FinishVarDecl ==> @[
			{FlushIds(2);}
		];
		LNode FinishPropertyDecl(bool isEvent = false) ==> @[
			{FlushIds(2);}
				
		];
		LNode FinishMethodDecl(bool isDelegate = false) ==> @[
			{FlushIds(2);}
		];
		LNode FinishExprStmt() ==> @[
			&{do something special when there's a _startingId} ...
			| Expr(StartStmt)
		];

		*/
	}}
}
