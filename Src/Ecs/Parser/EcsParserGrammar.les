import System;
import System.Collections.Generic;
import System.Linq;
import System.Text;
import System.Diagnostics;
import Loyc;
import Loyc.Syntax;
import Loyc.Syntax.Les;
import Loyc.Syntax.Lexing;
import Loyc.Collections;
import Loyc.Collections.Impl;

namespace Ecs.Parser
{
	using TT = TokenType;
	using S = CodeSymbols;
	using EP = EcsPrecedence;

	#rawText("#pragma warning disable 162");

	partial class EcsParser {
	[DefaultK(2), NoDefaultArm] [Verbosity(1)]
	LLLPG parser(laType(TokenType), matchType(int), allowSwitch(@true), setType(HashSet!int))
	{
		alias("(" = TT.LParen);
		alias(")" = TT.RParen);
		alias("[" = TT.LBrack);
		alias("]" = TT.RBrack);
		alias("{" = TT.LBrace);
		alias("}" = TT.RBrace);
		alias("." = TT.Dot);
		alias("->" = TT.PtrArrow);
		alias("::" = TT.ColonColon);
		alias("?." = TT.NullDot);
		alias("=" = TT.Set);
		alias("??=" = TT.CompoundSet);
		alias(":" = TT.Colon);
		alias("@" = TT.At);
		alias("``" = TT.BQString);
		alias("\\" = TT.Backslash);
		alias("*" = TT.Mul);
		alias("/,%" = TT.DivMod);
		alias("**" = TT.Power);
		alias("+" = TT.Add);
		alias("-" = TT.Sub);
		alias("++,--" = TT.IncDec);
		alias("&&" = TT.And);
		alias("||,^^" = TT.OrXor);
		alias("!" = TT.Not);
		alias("&" = TT.AndBits);
		alias("^" = TT.XorBits);
		alias("|" = TT.OrBits);
		alias("~" = TT.NotBits);
		alias("==,!=" = TT.EqNeq);
		alias("<" = TT.LT);
		alias(">" = TT.GT);
		alias("<=,>=" = TT.LEGE);
		alias(".." = TT.DotDot);
		alias("?" = TT.QuestionMark);
		alias("??" = TT.NullCoalesce);
		alias("=:" = TT.QuickBind);
		alias("==>" = TT.Forward);
		alias("$" = TT.Substitute);
		alias("=>" = TT.LambdaArrow);
		alias("," = TT.Comma);
		alias(";" = TT.Semicolon);
		
		static readonly _trait::Symbol = GSymbol.Get("trait");
		static readonly _alias::Symbol = GSymbol.Get("alias");
		static readonly _where::Symbol = GSymbol.Get("where");
		static readonly _assembly::Symbol = GSymbol.Get("assembly");
		static readonly _module  ::Symbol = GSymbol.Get("module");

		// Used to resolve the constructor ambiguity, in which "Foo()" could be a
		// constructor declaration or a method call. _spaceName is the name of the
		// current space, or #def (S.Def) when inside a method.
		_spaceName::Symbol;
		
		// ---------------------------------------------------------------------
		// -- Complex identifiers and type names -------------------------------
		// ---------------------------------------------------------------------

		// The complex identifier in EC# is a subset of the language of expressions,
		// and data types are a superset of the language of complex identifiers.
		// Complex identifiers can appear in the following contexts:
		// - Space names: namespace Foo.Bar<$T> {...}
		//   (and yes, I want to support template parameters on namespaces someday)
		// - Method/property names: bool global::System.IEquatable<T>.Equals(T other)
		// Data types can appear in the following contexts:
		// - Fields and properties: int* x { get; set; }
		// - Methods declarations: int[] f(Foo<T>[,][] x);
		// - Certain pseudo-functions: typeof(Foo<T[]>)
		// Note that complex identifiers can contain substitution expressions,
		// which, in turn, can contain expressions of any complexity, e.g. 
		// Foo<$(x*y(++z))>. Of course, complex identifiers also appear within 
		// normal expressions, but the expression grammar doesn't use the
		// main "ComplexId" rule, instead it's handled somewhat separately.

		[recognizer(def Scan_DataType(allowDimensions::bool = false))]
		rule DataType(allowDimensions::bool = false)::LNode @[
			e:=ComplexId()
			TypeSuffixOpt(allowDimensions, ref e)
			{return e;}
		];

		token ComplexId()::LNode @[
			e:=IdAtom 
			// There can be only a single "externAlias::" prefix in a complex Id.
			(	"::" e2:=IdAtom 
				{e = F.Call(S.ColonColon, e, e2, e.Range.StartIndex, e2.Range.EndIndex);}
			)?
			RestOfId(ref e)
			{return e;}
		];
			
		// identifier, $identifier, $(expr), or primitive type (int, string)
		rule IdAtom::LNode @[
			{r::LNode;}
			(	t:="$" e:=Atom {e=AutoRemoveParens(e);}
				{r = F.Call(S.Substitute, e, t.StartIndex, e.Range.EndIndex);}
			|	t:=(TT.Id|TT.TypeKeyword)
				{r = F.Id(t.Value -> Symbol, t.StartIndex, t.EndIndex);}
			) {return r;}
		];

		def AutoRemoveParens(node::LNode)::LNode
		{
			i::int = node.Attrs.IndexWithName(S.TriviaInParens);
			if (i > -1) (
				return node.WithAttrs(node.Attrs.RemoveAt(i));
			);
			return node;
		};

		[FullLLk] // http://loyc-etc.blogspot.ca/2013/12/bogus-ambiguity-warnings-in-lllpg.html
		[recognizer(def Scan_RestOfId())]
		rule RestOfId(ref r::LNode) @[
			TParams(ref r)?
			DotRestOfId(ref r)?
		];

		[recognizer(def Scan_DotRestOfId())]
		rule DotRestOfId(ref r::LNode)
		@[
			"." e:=IdAtom {r=F.Dot(r, e)}
			RestOfId(ref r)
		];

		[recognizer(def Scan_TParams())]
		rule TParams(ref r::LNode)
		@[
			{list::RWList!LNode = (new RWList!LNode());}
			{end::Token;}
			( "<" (list+=ComplexId ("," list+=ComplexId)*)? end=">"
			| "." t:="[" end="]" {list = AppendExprsInside(t, list);}
			| "!" t:="(" end=")" {list = AppendExprsInside(t, list);}
			)
			{
				list.Insert(0, r);
				start::int = r.Range.StartIndex;
				r = F.Call(S.Of, list.ToRVList(), start, end.EndIndex);
			}
		];

		count::int; // hack allows Scan_TypeSuffixOpt() to compile

		[recognizer(def Scan_TypeSuffixOpt(allowDimensions::bool))]
		rule TypeSuffixOpt(allowDimensions::bool, ref e::LNode)::bool
		@[
			{count::int; result::bool = false;}
			(	"?" {e = F.Of(F.Id(S.QuestionMark), e); result=true;}
			|	"*" {e = F.Of(F.Id(S._Pointer), e);     result=true;}
			|	// int[][,] means "array of (two-dimensional array of int)", so we
				// must process array adornments in reverse order.
				{var dims = InternalList!int.Empty;}
				(greedy(&{(count=CountDims(LT($LI), allowDimensions)) > 0} "[" "]" {dims.Add(count);}))+
				{
					for (i::int = dims.Count - 1, i >= 0, i--)
						e = F.Of(F.Id(S.GetArrayKeyword(dims[i])), e);
					result = true;
				}
			)*
			{return result;}
		];
			
		// ---------------------------------------------------------------------
		// -- Expressions ------------------------------------------------------
		// ---------------------------------------------------------------------

		// Parsing EC# expressions is very tricky. Here are some of the things 
		// that make it difficult, especially in an LL(k) parser:
		//    
		// 1. Parenthesis: is it a cast or a normal expression?
		//    (A<B,C>)y      is a cast
		//    (A<B,C>)-y     is NOT a cast
		//    (A<B,C>)(-y)   is a cast
		//    (A<B,C>)(as B) is NOT a cast (well, the second part is)
		//    x(A<B,C>)(-y)  is NOT a cast
		//    -(A<B,C>)(-y)  is a cast
		//    $(A<B,C>)(-y)  is NOT a cast
		//    (A<B,C>){y}    is a cast
		//    (A<B,C>)[y]    is NOT a cast
		//    (A<B,C>)++(y)  is NOT a cast (it's post-increment and call)
		//    (A<B> C)(-y)   is NOT a cast
		//    ([] A<B,C>)(y) is NOT a cast (empty attr list defeats cast)
		//    (A+B==C)y      is nonsensical
		//    x(A<B,C>)y     is nonsensical
		// 2. In-expr var declarations: is "(A<B,C>D)" a variable declaration?
		//    (A<B,C>D) => D.Foo() // variable declaration
		//    (A<B,C>D) = Foo()    // variable declaration
		//    (f1, f2) = (A<B,C>D) // tuple
		//    Foo(A<B,C>D)         // method with two arguments
		//    void Foo(A<B,C>D)    // variable declaration at statement level
		//    Foo(A<B,C>D)         // variable declaration at statement level if 'Foo' is the space name
		//                         // (i.e. when 'Foo' is a constructor)
		// 3. Less-than: is it a generics list or an operator? Need unlimited lookahead.
		//    (A<B,C)    // less-than operator
		//    (A<B,C>)   // generics list
		//    (A<B,C>D)  // context-dependent
		// 4. Brackets. Is "Foo[]" a data type, or an indexer with no args?
		//    (Foo[]) x; // data type: #of(#[], Foo)
		//    (Foo[]).x; // indexer:   #[](Foo)
		// 5. Does "?" make a nullable type or a conditional operator?
		//    Foo<B> ? x = null;     // nullable type
		//    Foo<B> ? x = null : y; // conditional operator
		
		// NOT CURRENTLY USED
		// The Ambiguity flags help communicate contextual nuances between the 
		// rules, to distinguish some of the above cases.
		[Flags]
		enum Ambiguity { 
			// Inputs
			AllowUnassignedVarDecl = 1;
			StatementLevel = 2;
			StopAtArgumentList = 8; // helps parse method declaration
			ExpectCast = 4;         // used in (...)x
			ExpectType = 8;         // used in typeof(...)

			// Outputs
			BlankIndexed = 0x0040;
			TypeSuffix = 0x0080;
			IsExpr = 0x0100;        // implies "not a type"
			IsCall = 0x0200;        // implies "not a type"
			HasAttrs = 0x0400;    // defeats cast
			IsTuple = 0x0800;     // multiple arguments (or no arguments)
			Error = 0x1000;
			NotAType = IsExpr|IsCall;
				
			Type = BlankIndexed | TypeSuffix;
		};

		static readonly MinPrec::int = Precedence.MinValue.Lo;
		/// Context: beginning of statement (#namedArg not supported, allow multiple #var decl)
		public static readonly StartStmt::Precedence    = (new Precedence(MinPrec, MinPrec, MinPrec));
		/// Context: beginning of expression (#var must have initial value)
		public static readonly StartExpr::Precedence    = (new Precedence(MinPrec+1, MinPrec+1, MinPrec+1));
		/// Context: middle of expression, top level (#var and #namedArg not supported)
		public static readonly ContinueExpr::Precedence = (new Precedence(MinPrec+2, MinPrec+2, MinPrec+2));

		// Types of expressions:
		// - identifier
		// - (parenthesized expr)
		// - (tuple,)
		// - ++prefix_operators
		// - suffix_operators++
		// - infix + operators, including x => y
		// - the ? conditional : operator
		// - generic<arguments>, generic!arguments, generic.[arguments]
		// - (old_style) casts
		// - call_style(->casts)
		// - method_calls(with, arguments)
		// - typeof(and other pseudofunctions)
		// - indexers[with, indexes]
		// - new Object()
		// - { code in braces; new scope }
		// - #{ code in braces; old scope }
		// - delegate(...) {...}
		// - from x in expr... (LINQ)
		
		// Atom is: Id, TypeKeyword, $Atom, .Atom, new ..., (ExprStart), {Stmts},
		rule Atom::LNode @[
			{r::LNode;}
			(	t:=("$"|".") e:=Atom {e=AutoRemoveParens(e);}
				{r = F.Call(t.Value -> Symbol, e, t.StartIndex, e.Range.EndIndex);}
			|	t:=(TT.Id | TT.TypeKeyword | TT.(noMacro(this)) | TT.(noMacro(base)))
				{r = F.Id(t.Value -> Symbol, t.StartIndex, t.EndIndex);}
			|	t:=(TT.Number | TT.String | TT.SQString | TT.OtherLit | TT.Symbol)
				{r = F.Literal(t.Value, t.StartIndex, t.EndIndex);}
			|	r=ExprInParensAuto // (...)
			|	r=BracedBlock // {...}
			|	at:="@" t:="[" rb:="]" {r = F.Literal(t.Children, at.StartIndex, rb.EndIndex);}
				{r = F.Literal(t.Children, t.StartIndex, rb.EndIndex);}
			|	{type::LNode = F._Missing;}
				// kinds of "new" expressions: 
				// new Type(...) <=> #new(Type(...))
				// new Type(...) { ... } <=> #new(Type(...), ...)
				// new Type { ... } <=> #new(Type(), ...)
				// new { ... } <=> #new(@``, ...)
				TT.@new 
				(	&{LT($LI).Count == 0}
					lb:="[" rb:="]" {type=F.Id(S.Bracks, lb.StartIndex, rb.EndIndex);}
				|	type=DataType(true))?
				{var list = (new RWList!LNode());}
				(	lp:="(" ")"
					{list.Add(type.WithArgs(ExprListInside(lp).ToRVList()));}
					(lb:="{" "}" {AppendExprsInside(lb, list)})?
				|	{list.Add(type.WithArgs());}
					lb:="{" "}"
					{AppendStmtsInside(lb, list)}
				)
				{r = F.Call(S.New, list.ToRVList());}
			|	t:=(TT.@typeof | TT.@checked | TT.@unchecked | TT.(noMacro(@default)) | TT.@sizeof)
				args:="(" rp:=")"
				{r = F.Call(t.Value -> Symbol, ExprListInside(args), t.StartIndex, rp.EndIndex);}
			|	t:=TT.@delegate args:="(" ")" block:="{" rb:="}"
				{r = F.Call(S.Lambda, F.Tuple(ExprListInside(args).ToRVList()), F.Braces(StmtListInside(block).ToRVList(), block.StartIndex, rb.EndIndex), t.StartIndex, rb.EndIndex);}
			|	error {r = Error("Invalid expression");} (greedy(~(","|";")))* 
				/*hack, avoid long analysis time*/ (~(~EOF) =>{})
			) {return r;}
		];

		private rule ExprInParensAuto::LNode @[
			// This gate is used to avoid a slug that quadruples analysis time elsewhere in the grammar
			"(" ")" =>
			(	&(ExprInParens(true) ("="|"=>"))
				r:=ExprInParens(true)  {return r;}
			/	r:=ExprInParens(false) {return r;}
			)
		];

		private rule PrimaryExpr::LNode @[
			e:=Atom
			greedy
			(	op:=("."|"->"|"::"|"=:")
				rhs:=Atom       {e = F.Call(op.Value -> Symbol, e, rhs, e.Range.StartIndex, rhs.Range.EndIndex);}
			/	e=PrimaryExpr_NewStyleCast(e)
			/	lp:="(" rp:=")" {e = F.Call(e, ExprListInside(lp), e.Range.StartIndex, rp.EndIndex);}
			|	lb:="[" rb:="]" {var list = (new RWList!LNode() { e });}
				                {e = F.Call(S.Bracks, AppendExprsInside(lb, list).ToRVList(), e.Range.StartIndex, rb.EndIndex);}
			|	// Post-inc or post-dec
				t:="++,--"      {e = F.Call(t.Value == S.PreInc ? S.PostInc : S.PostDec, e, e.Range.StartIndex, t.EndIndex);}
			|	// <Type parameters>
				&(TParams (~TT.Id | EOF)) ("<"|"!"|"." "[") => TParams(ref e)
			)*
			{return e;}
		];

		private rule PrimaryExpr_NewStyleCast(e::LNode)::LNode @[
			&{Down($LI) && Up(LA0 == TT.@as || LA0 == TT.@using || LA0 == TT.PtrArrow)}
			lp:="(" rp:=")"
			(=>
				{Down(lp);}
				kind:=("->" | TT.@as | TT.@using) type:=ExprStart(false) EOF
				{return Up(F.Call(kind.Value == S.PtrArrow ? S.Cast : (kind.Value -> Symbol), e, type, 
				                  e.Range.StartIndex, rp.EndIndex));}
			)
		];

		private rule NullDotExpr::LNode @[
			e:=PrimaryExpr
			(
				"?." rhs:=PrimaryExpr {e = F.Call(S.NullDot, e, rhs, e.Range.StartIndex, rhs.Range.EndIndex);}
			)*
			{return e;}
		];

		[k(3)] // to distinguish (cast) expr from (parens)
		private rule PrefixExpr::LNode @[
			(	op:=("+"|"-"|"!"|"~"|"++,--"|"*"|"&") e:=PrefixExpr
				{return F.Call(op.Value -> Symbol, e, op.StartIndex, e.Range.EndIndex);}
			|	// C-style cast
				&{Down($LI) && Up(Scan_DataType() && LA0 == EOF)}
				lp:="(" ")"
				(&!("+"|"-"|("++,--" "(")))
				e:=PrefixExpr
				{Down(lp); return F.Call(S.Cast, e, Up(DataType()), lp.StartIndex, e.Range.EndIndex);}
			/	op:="**"
				e:=PrefixExpr
				{return F.Call(S._Dereference, F.Call(S._Dereference, e, 
						op.StartIndex+1, e.Range.EndIndex), 
						op.StartIndex, e.Range.EndIndex);}
			/	e:=NullDotExpr
				{return e;}
			)
		];

		// This rule handles all lower precedence levels, from ** down to assignment
		// (=). This rule uses the "precedence floor" concept, documented in 
		// Loyc.Syntax.Precedence, to handle different precedence levels. The 
		// traditional approach is to define a separate rule for every precedence
		// level. By collapsing many precedence levels into a single rule, there are
		// two benefits: 
		// (1) shorter code.
		// (2) potentially better performance: using a separate rule per precedence
		//     level causes a new stack frame to be created for each level, regardless
		//     of the operators present in the actual expression being parsed. For
		//     example, to parse the simple expression "Hello" the traditional way 
		//     requires 20 rules and therefore 20 stack frames if there are 20 
		//     precedence levels. On the other hand, the "precedence floor" approach 
		//     requires an extra precedence check, so it may be slower when there are 
		//     few levels. Note: EC# has 22 precedence levels, and this method
		//     handles the lower 18 of them.
		//
		// The higher levels of the EC# expression parser do not use this trick
		// because the higher precedence levels have some complications, such as 
		// C-style casts and <type arguments>, that I prefer to deal with separately.
		private rule Expr(context::Precedence)::LNode @[
			{Debug.Assert(context.CanParse(EP.Prefix));}
			{prec::Precedence;}
			e:=PrefixExpr
			greedy
			(	// Infix operator
				&{[Local] context.CanParse(prec=InfixPrecedenceOf($LA))}
				op:=( "**"|"*"|"/,%"|"+"|"-"|"~"|".."|"<"|">"|"<=,>="|"==,!="
				    | "&"|"|"|"^"|"&&"|"||,^^"|"??"|"="|"??="|"=>"|TT.BQString
				    | TT.@is | TT.@as | TT.@in )
				rhs:=Expr(prec)
				{e = F.Call(op.Value -> Symbol, e, rhs, e.Range.StartIndex, rhs.Range.EndIndex);}
				{e.BaseStyle = NodeStyle.Operator;}
			|	// "using" cast (special-case in order to set its name to #usingCast instead of #using)
				&{[Local] context.CanParse(prec=InfixPrecedenceOf($LA))}
				op:=TT.@using
				rhs:=Expr(prec)
				{e = F.Call(S.UsingCast, e, rhs, e.Range.StartIndex, rhs.Range.EndIndex);}
				{e.BaseStyle = NodeStyle.Operator;}
			|	// Shift operators (two LT or GT in a row)
				&{[Local] context.CanParse(EP.Shift)}
				&{LT($LI).EndIndex == LT($LI+1).StartIndex}
				(	"<" "<" rhs:=Expr(EP.Shift)
					{e = F.Call(S.Shl, e, rhs, e.Range.StartIndex, rhs.Range.EndIndex);}
				|	">" ">" rhs:=Expr(EP.Shift)
					{e = F.Call(S.Shr, e, rhs, e.Range.StartIndex, rhs.Range.EndIndex);}
				)
				{e.BaseStyle = NodeStyle.Operator;}
			|	// Conditional operator
				&{[Local] context.CanParse(EP.IfElse)}
				"?" then:=Expr(ContinueExpr) ":" else:=Expr(EP.IfElse)
				{e = F.Call(S.QuestionMark, e, then, @else, e.Range.StartIndex, else.Range.EndIndex);}
				{e.BaseStyle = NodeStyle.Operator;}
			)*
			{return e;}
		];
		
		public rule ExprStart(allowUnassignedVarDecl::bool)::LNode @[
			{e::LNode;}
			{attrs::RWList!LNode = null;}
			NormalAttributes(ref attrs)
			(	&DetectVarDecl(allowUnassignedVarDecl)
				IdAtom => e=VarDeclExpr
			/	e=Expr(ContinueExpr)
			)
			{if (attrs != null) e = e.PlusAttrs(attrs.ToRVList());}
			{return e;}
		];

		// Only the recognizer is used. TODO: add LLLPG feature to suppress standard rule part
		private rule DetectVarDecl(allowUnassigned::bool) @[
			VarDeclStart ("=" / &{allowUnassigned})
		];
		private rule VarDeclExpr::LNode @[
			pair:=VarDeclStart 
			{var(type::LNode = pair.Item1, name::LNode = pair.Item2);}
			(	"=" init:=Expr(ContinueExpr)
				{return F.Call(S.Var, type, 
					F.Call(S.Set, name, init, name.Range.StartIndex, init.Range.EndIndex),
					type.Range.StartIndex, init.Range.EndIndex);}
			)?
			{return F.Call(S.Var, type, name, type.Range.StartIndex, name.Range.EndIndex);}
		];

		private rule VarDeclStart::Pair!(LNode, LNode) @[
			e:=DataType(false)
			name:=TT.Id
			{MaybeRecognizeVarAsKeyword(ref e);}
			{return Pair.Create(e, F.Id(name.Value -> Symbol, name.StartIndex, name.EndIndex));}
		];

		static readonly _var::Symbol = GSymbol.Get("var");
		
		private def MaybeRecognizeVarAsKeyword(ref type::LNode)
		{
			// Recognize "var" (but not @var) as a contextual keyword.
			rng::SourceRange;
			if type.IsIdNamed(_var) && (rng=type.Range).Source.TryGet(rng.StartIndex, 'v') == 'v' {
				type = F.Id(S.Missing, rng.StartIndex, rng.EndIndex);
			};
		};

		private rule ExprInParens(allowUnassignedVarDecl::bool)::LNode
		@[
			lp:="(" rp:=")"
			{
				// Note: we invoke ExprInParensOrTuple inside an action, hiding the
				// invocation from LLLPG, to avoid creating a recognizer for Expr.
				if (!Down(lp)) { return F.Call(S.Tuple, lp.StartIndex, rp.EndIndex); };
				return Up(ExprInParensOrTuple(allowUnassignedVarDecl, lp.StartIndex, rp.EndIndex));
			}
		];
		private rule ExprInParensOrTuple(allowUnassignedVarDecl::bool, startIndex::int, endIndex::int)::LNode @[
			e:=ExprStart(allowUnassignedVarDecl)
			(	"," _* =>
				{var list = (new RVList!LNode() { e });}
				(	"," list+=ExprStart(allowUnassignedVarDecl)
				|	","
				)*
				{return F.Tuple(list, startIndex, endIndex);}
			)?
			EOF
			{return F.InParens(e, startIndex, endIndex);}
		];
		private rule BracedBlock::LNode
		@[
			t:="{" "}" {return F.Braces(StmtListInside(t).ToRVList());}
		];

		// ---------------------------------------------------------------------
		// -- Attributes -------------------------------------------------------
		// ---------------------------------------------------------------------
		
		token NormalAttributes(ref attrs::RWList!LNode) @[
			(
				t:="[" "]" {AppendExprsInside(t, attrs = attrs ?? new RWList!LNode());}
			)*
			(
				t:=TT.AttrKeyword 
				{attrs = attrs ?? new RWList!LNode();}
				{attrs.Add(F.Id(t.Value -> Symbol, t.StartIndex, t.EndIndex));}
			)*
		];
			
		// "word attributes" are a messy feature of EC#. C# has a few non-
		// keyword attributes that appear at the beginning of a statement, such
		// as "partial", "yield" and "async". EC# generalizes this concept to 
		// "word attributes", which can be any normal identifier.
		//
		// BTW: "word attributes" are not really "contextual keywords" in the C# 
		// sense, because the identifiers are not recognized by the parser. The
		// only true contextual keywords in EC# are "var", "module" and "assembly"
		// ("var" is not a contextual keyword in C# in the same way; in EC#, 
		// "var" is identified as a keyword by the parser, but in C# it is 
		// identified during semantic analysis.)
		//
		// Since they're not keywords, word attributes are difficult because:
		// 1. Lots of statements start with words that are not word attributes, 
		//    such as "foo=0", "foo* x = null", "foo x { ... }", and "foo x();"
		//    Somehow we have to figure out which words are attributes.
		// 2. Not all statements accept word attributes. But the attributes 
		//    appear before the statement, so how can we tell if we should
		//    be expecting word attributes or not?
		//
		// Using an LL(k) parser generator is quite limiting in this situation;
		// normal lookahead is strictly limited and we can't backtrack except 
		// via "and" predicates or custom code. On the other hand, I still think 
		// LL(k) is the best way to parse, precisely because it minimizes 
		// backtracking.
		// 
		// There are lots of "keyword-based" statements that accept word
		// attributes (think "partial class" and "yield return"), which are easy
		// to handle. Our main difficulty is the non-keyword statements:
		// 1. statements that can begin with an identifier, but also accept
		//    word attributes:
		//    - word type* name ... // field, property or method
		//    - word type? name ... // field, property or method
		//    - word type[,][] name ... // field, property or method
		//    - word type<x> name ... // field, property or method
		//    - word type name(); // method decl
		//    - word type name<x>(); // method decl
		//    - word type<x> name(); // method decl
		//    - word type<x> name<x>(); // method decl
		//    - word this();         // except inside methods
		//    - word this<x>();      // except inside methods
		//    - word label:
		// 2. statements that can start with an identifier, and do not accept 
		//    word attributes:
		//    - foo();     // method call OR constructor
		//    - foo<x>();
		//    - foo = 0;
		//    - foo - bar;
		// Notice that if a word is followed by an operator of any kind, it 
		// can't be an attribute; but if it is followed by another word, it's
		// unclear. In particular, notice that for "A B<x>...", "A" is sometimes
		// an attribute and sometimes not. In "A B<x> C", A is an attribute,
		// but in "A B<x>()" it is a return type. The same difficulty exists
		// in case of alternate generics specifiers such as "A B!(x)" and types
		// with suffixes, like "A int?*".
		// 
		// My strategy here is to use lookahead with &(...) to decide if a word 
		// (or the "new" keyword) is an attribute or not.

		_triviaWordAttribute::LNode;

		token WordAttributes(attrs::RWList!LNode)
		@[
			{	// Optimize the common case (non-exhaustive short circuit)
				la1_::TokenType = LA(1);
				if LA0 == TT.Id && (la1_ == TT.Set || la1_ == TT.LParen || la1_ == TT.Dot) return;
			}
			(	t:=TT.AttrKeyword {attrs.Add(F.Id(t.Value -> Symbol, t.StartIndex, t.EndIndex));}
			|	t:=(TT.Id|TT.@new)
				&(	DataType TT.Id
				|	TT.Id? (TT.AttrKeyword | TT.@new)
				|	&{_spaceName!=S.Def} TT.(noMacro(this))
				|	TT.@checked "{" "}" | TT.@unchecked "{" "}" | TT.(noMacro(@default)) ":"
				|	( TT.@namespace | TT.@class | TT.@struct | TT.@interface | TT.@enum 
					| TT.@delegate | TT.@event | TT.@case | TT.(noMacro(break)) | TT.(noMacro(continue)) | TT.@do 
					| TT.@fixed | TT.@for | TT.@foreach | TT.@goto | TT.@lock | TT.(noMacro(return))
					| TT.@switch | TT.(noMacro(throw)) | TT.@try | TT.@using | TT.@while )
				)
				{
					_triviaWordAttribute = _triviaWordAttribute ?? F.Id(S.TriviaWordAttribute);
					attrs.Add(F.Attr(_triviaWordAttribute, F.Id("#" + t.Value.ToString(), t.StartIndex, t.EndIndex)));
				}
			)*
		];

		/*
		token WordAttributes_Conservative(attrs::RWList!LNode, out wordAttrCount::int)
		@[
			{	// Optimize the common case (non-exhaustive short circuit)
				la1_::TokenType = LA(1);
				if LA0 == TT.Id && (la1_ == TT.Set || la1_ == TT.LParen || la1_ == TT.Dot) return;
			
				oldPosition::int = InputPosition;
				lastWords::int = 0; // number of consecutive word attributes
				newPosition::int = -1; // position when 'new' was encountered
			}
			// Gather up all potential word attributes into a list.
			(	TT.Id                                                     {lastWords++;}
			|	(TT.AttrKeyword | TT.@new {newPosition = InputPosition;}) {lastWords = 0;}
			)*
			{
				count::int = InputPosition - oldPosition;
				if count == 0 return;
				
				// Next we have to figure out "roughly" how many of the words were 
				// really attributes (often it will be none of them) and backtrack 
				// if we scanned too many. But we don't have to backtrack if we 
				// reach a keyword statement (class, return, if, etc.) or if 
				// lastWords==0. This method is "conservative" in that it might 
				// backtrack by (at most) one word more than necessary (which is 
				// much easier than doing a perfect job.)
				la0 = LA0;
				if (lastWords > 0 && !KeywordsWithWordAttributes.Contains(la0 -> int)) {
					if (la0 == TT.LBrace || la0 == TT.LParen || la0 == TT.(noMacro(this)) && LA(1) == TT.LBrack)
						if (lastWords >= 2) {
							InputPosition -= 2; // detected method, var or prop decl
						} else
							InputPosition--; // detected expression, get {...}, etc.
					} else if (la0 == TT.TypeKeyword) {
						// Backtrack only if type keyword is preceded by 'new',
						// which could be a new expr: new foo(...)
						if (newPosition == InputPosition - 1)
					} else {
						using (new SavePosition(this, lookaheadAmt))
					};
					return;
				};

				AddWordAttrs(attrs, count);

				// Word attributes are allowed on variable, method, and property
				// decls; unfortunately, we may have scanned past the type already,
				// and maybe the name too. Detect such cases and backtrack.
				// First check
				if (lastWords >= 2 && (la0 == TT.LBrace || la0 == TT.LParen || la0 == TT.(noMacro(this)) && LA(1) == TT.LBrack)) {
					InputPosition -= 2;
					AddWordAttrs(attrs, count - 2);
					return;
				};

				if (la0 != TT.TypeKeyword && lastWords != 0) {
					// It's a sure bet that the final word is not an attribute: it 
					// will be part of either the type or the name of a method/var/
					// property decl, or the beginning of an expression.
					InputPosition--;
					count--;
				}

				
				AddWordAttrs(attrs, count)
			}
		];
		private def AddWordAttrs(attrs::RWList!LNode, count::int)
		{
			for (i::int = 0, i < count, i++) {
				var token = LT(i - count);
				node::LNode;
				if (token.Type() == TT.Id) {
					node = F.Attr(F.Id(S.TriviaWordAttribute),
						F.Id("#" + token.Value.ToString(), token.StartIndex, token.EndIndex));
				} else
					node = F.Id(token.Value -> Symbol, token.StartIndex, token.EndIndex);
				attrs.Add(node);
			};
		};

		//[recognizer(def Scan_KeywordWithWordAttributes())]
		//rule KeywordsWithWordAttributes @[ 
		//	( TT.@namespace | TT.@class | TT.@struct | TT.@interface | TT.@enum 
		//	| TT.@delegate | TT.@event | TT.@case | TT.(noMacro(break)) | TT.(noMacro(continue)) | TT.@do 
		//	| TT.@fixed | TT.@for | TT.@foreach | TT.@goto | TT.@lock | TT.(noMacro(return))
		//	| TT.@switch | TT.(noMacro(throw)) | TT.@try | TT.@using | TT.@while )
		//];
		rule AfterWordAttributes @[
			(	DataType TT.Id
			|	&{_spaceName!=S.Def} TT.(noMacro(this))
			|	TT.@checked "{" "}" | TT.@unchecked "{" "}" | TT.(noMacro(@default)) ":"
			|	( TT.@namespace | TT.@class | TT.@struct | TT.@interface | TT.@enum 
				| TT.@delegate | TT.@event | TT.@case | TT.(noMacro(break)) | TT.(noMacro(continue)) | TT.@do 
				| TT.@fixed | TT.@for | TT.@foreach | TT.@goto | TT.@lock | TT.(noMacro(return))
				| TT.@switch | TT.(noMacro(throw)) | TT.@try | TT.@using | TT.@while )
			)
		];*/

		// ---------------------------------------------------------------------
		// -- Statements -------------------------------------------------------
		// ---------------------------------------------------------------------
		
		_stmtAttrs::RWList!LNode = (new RWList!LNode());

		public rule Stmt::LNode @[
			{_stmtAttrs.Clear();}
			NormalAttributes(ref _stmtAttrs)
			WordAttributes(_stmtAttrs)
			{var attrs = _stmtAttrs.ToRVList();}
			{r::LNode;}
			(	// Declaration-level statements
				r=SpaceDecl(attrs)  // namespace, class, struct, interface, enum
				//|r=NonKeywordSpaceDecl
			|	r=AssemblyOrModuleAttribute(attrs)
			|	r=EventDecl(attrs)
			|	r=DelegateDecl(attrs)
			|	&(DataType ComplexId)
				r=MethodOrPropertyOrVar(attrs)
				
				// Executable statements
			/	r=Expr(ContinueExpr) (default ";" | EOF {r = F.Call(S.Result, r, r.Range.StartIndex, r.Range.EndIndex);})
				{r = r.WithAttrs(attrs);}
				//|	LabelStmt // includes default:
				//|	BreakStmt
				//|	CaseStmt
				//|	CheckedStmt
				//|	ContinueStmt
				//|	DoStmt
				//|	EventStmt
				//|	FixedStmt
				//|	ForStmt
				//|	ForEachStmt
				//|	GotoStmt
				//|	&{nWords==0} IfStmt
				//|	LockStmt
				//|	ReturnStmt
				//|	SwitchStmt
				//|	ThrowStmt
				//|	TryStmt
				//|	UncheckedStmt
				//|	UsingStmt
				//|	WhileStmt 
			|	t:=";" {r = F.Id(S.Missing, t.StartIndex, t.EndIndex);}
			|	error ScanToEndOfStmt 
				{r = Error("Syntax error: statement expected");}
			)
			{return r;}
		];

		private token ScanToEndOfStmt() @[
			// Used for error recovery
			(greedy(~(";"|"{")))*
			greedy(";" | "{" "}"?)?
		];

		// ---------------------------------------------------------------------
		// -- namespace, class, struct, interface, enum ------------------------
		// ---------------------------------------------------------------------

		rule WhereClausesOpt(ref name::LNode) {
			// TODO: add 'where' clauses to type name
		};
		private rule WhereClause @[
			// TODO
			&{Is($LI,_where)} TT.Id
		];
		def Is(li::int, value::Symbol)::bool
		{
			return LT(li).Value == value;
		};


		private rule SpaceDecl(attrs::RVList!LNode)::LNode @[
			t:=(TT.@namespace | TT.@class | TT.@struct | TT.@interface | TT.@enum)
			{var kind = t.Value -> Symbol;}
			name:=ComplexId
			bases:=BaseListOpt
			WhereClausesOpt(ref name)
			(	end:=";"          {return F.Call(kind, name, bases,       t.StartIndex, end.EndIndex).WithAttrs(attrs);}
			|	body:=BracedBlock {return F.Call(kind, name, bases, body, t.StartIndex, body.Range.EndIndex).WithAttrs(attrs);}
			)
		];
		private rule BaseListOpt::LNode @[
			(	{var bases = (new RVList!LNode());}
				":" bases+=DataType
				("," bases+=DataType)*
				{return F.List(bases);}
			|	{return F.List();}
			)
		];

		// ---------------------------------------------------------------------
		// -- assembly or module attribute -------------------------------------
		// ---------------------------------------------------------------------

		[recognizer(def Scan_AsmOrModLabel())] // recognizer used by AssemblyOrModuleAttribute
		private rule AsmOrModLabel::Token @[
			&{LT($LI).Value==_assembly || LT($LI).Value==_module} t:=TT.Id ":"
			{return t;}
		];

		private rule AssemblyOrModuleAttribute(attrs::RVList!LNode)::LNode
		@[
			&{Down($LI) && Up(Try_Scan_AsmOrModLabel(0))} lb:="[" rb:="]"
			(=> {Down(lb);} 
				kind:=AsmOrModLabel 
				{var list = (new RWList!LNode());}
				ExprList(list) 
				{
					Up();
					var r = F.Call(kind.Value == _module ? S.Module : S.Assembly, list.ToRVList(), lb.StartIndex, rb.EndIndex);
					return r.WithAttrs(attrs);
				}
			)
		];

		// ---------------------------------------------------------------------
		// -- methods, properties, variable/field declarations -----------------
		// ---------------------------------------------------------------------

		private rule MethodOrPropertyOrVar(attrs::RVList!LNode)::LNode @[
			{r::LNode;}
			type:=DataType
			(	// Variable declaration
				{MaybeRecognizeVarAsKeyword(ref type);}
				{var parts = (new RVList!LNode() { type });}
				     parts+=NameAndMaybeInit(IsArrayType(type))
				("," parts+=NameAndMaybeInit(IsArrayType(type)))* end:=";"
				{r = F.Call(S.Var, parts, type.Range.StartIndex, end.EndIndex);}
			/	name:=ComplexId
				(	// Method declaration/definition
					lp:="(" rp:=")" 
					(	default end:=";"  {r = F.Def(type, name, ArgTuple(lp, rp), null, type.Range.StartIndex, end.EndIndex);}
					|	body:=BracedBlock {r = F.Def(type, name, ArgTuple(lp, rp), body, type.Range.StartIndex, body.Range.EndIndex);}
					);
				|	// Property definition
					body:=BracedBlock
					{r = F.Property(type, name, body, type.Range.StartIndex, body.Range.EndIndex);}
				|	error ScanToEndOfStmt
					{Error("Syntax error in method, property, or variable declaration");}
				)
			)
			{return r.WithAttrs(attrs);}
		];

		def IsArrayType(type::LNode)::bool 
		{
			// Detect an array type, which has the form #of(#[,], Type)
			return type.Calls(S.Of, 2) && S.IsArrayKeyword(type.Args[0].Name);
		};

		def ArgTuple(lp::Token, rp::Token)::LNode
		{
			var args = ExprListInside(lp);
			return F.Tuple(args.ToRVList(), lp.StartIndex, rp.EndIndex);
		};

		private rule NameAndMaybeInit(isArray::bool)::LNode @[
			name:=TT.Id
			{r::LNode = F.Id(name.Value -> Symbol, name.StartIndex, name.EndIndex);}
			(	"=" 
				// The initializer for an array in C# can be a braced list of expressions.
				// EC# also allows braced blocks as expressions, so I'll distinguish the
				// cases by checking for semicolons. If there's a ";", it's an EC# block.
				// If it is a C# initializer, treat {...} as new[] {...} (#new(#[](), ...})
				(	&{[Local] isArray}
					&{[Local] Down($LI) && Up(HasNoSemicolons())} 
					lb:="{" rb:="}"
					{
						var initializers = StmtListInside(lb);
						initializers.Insert(0, F.Call(S.Bracks, lb.StartIndex, lb.StartIndex));
						var init = F.Call(S.New, initializers.ToRVList(), lb.StartIndex, rb.EndIndex);
						r = F.Call(S.Set, r, init, name.StartIndex, rb.EndIndex);
					}
				/	init:=ExprStart(false)
					{r = F.Call(S.Set, r, init, name.StartIndex, init.Range.EndIndex);}
				)
			)?
			{return r;}
		];
		[recognizer(def HasNoSemicolons()::bool)]
		private rule NoSemicolons @[ ~";"* EOF ];

		// ---------------------------------------------------------------------
		// Event declaration ---------------------------------------------------
		// ---------------------------------------------------------------------

		private rule EventDecl(attrs::RVList!LNode)::LNode @[
			{r::LNode;}
			k:=TT.@event type:=DataType name:=ComplexId
			(	default end:=";"  {r = F.Call(S.Event, type, name, k.StartIndex, end.EndIndex);}
			|	body:=BracedBlock {r = F.Call(S.Event, type, name, body, k.StartIndex, body.Range.EndIndex);}
			)
			{return r.WithAttrs(attrs);}
		];

		// ---------------------------------------------------------------------
		// Delegate type definition --------------------------------------------
		// ---------------------------------------------------------------------

		private rule DelegateDecl(attrs::RVList!LNode)::LNode @[
			k:=TT.@delegate type:=DataType name:=ComplexId
			lp:="(" rp:=")" end:=";"
			{var r = F.Call(S.Delegate, type, name, ArgTuple(lp, rp), k.StartIndex, end.EndIndex);}
			{return r.WithAttrs(attrs);}
		];

		// ---------------------------------------------------------------------
		// ExprList and StmtList -----------------------------------------------
		// ---------------------------------------------------------------------

		rule ExprOpt::LNode @[
			e:=ExprStart(false) {return e;}
			| {
				var i = GetTextPosition(InputPosition);
				return F.Id(S.Missing, i, i);
			}
		];
		rule ExprList(list::RWList!LNode) @[
			nongreedy(
				list+=ExprOpt
				( "," list+=ExprOpt
				| error {Error("Syntax error in expression list");} ~","*)*
			)?
			EOF
		];
		rule StmtList(list::RWList!LNode) @[
			(list+=Stmt)*
			EOF
		];

	/*
		rule ExprStart()
		@[
			NormalAttributes?
			( &VarDecl(f) VarDecl(f)
			| Expr(ContinueExpr, ref f)
			)
		];
		
		// Combines the previous precedence floor with that of a prefix operator
		Precedence RP(Precedence prev, Precedence pre) {
			return new Precedence(prev.Lo, prev.Hi, prev.Left, Math.Max(prev.Right, pre.Right));
		}
			
			
		rule NewExpr @[ 
			{r::LNode; f::Ambiguity = 0;}
			"new" 
				
			typeAndCons:=Expr(EP.Primary, ref f);
			{                     
				if ((f & Ambiguity.NotAType) != 0)
					Error(typeAndCons, "Type expected after 'new'");
				return 
			}
			(	t:="{}"
				{
					var list = ExprListInside(t);
					list.Insert(0, typeAndCons);
					r = F.Call(S.New, list.ToRVList());
				}
			|	{r = F.Call(S.New, typeAndCons);}
			{return r;}
		];
		
		rule CastOrParens(context::Precedence) @[
			// A cast requires...
			// - Precedence floor of Prefix or lower
			// - Must be followed by Id, a literal, {...}, '$', 
			//   or a "()" that is not one of the new cast operators
			// - That the initial parens are a data type
			// - That the initial parens are not an argument list 
			//   (if so this rule is not called in the first place)
			{r::LNode; f::Ambiguity;}
			(
				t:="(" ")"
				&("$"|TT.Id|TT.SQString|TT.DQString|TT.Number|"{" "}" | &!{IsNewCastOp(\LI)} "(" ")")
				(("$"|TT.Id|TT.SQString|TT.DQString|TT.Number|"{" "}" | &!{IsNewCastOp(\LI)} "(" ")")
					=> // Block further lookahead
					{r = ExprOrTupleInside(t, ref f, false);}
					(	// We still don't know if it's a cast until this part runs
						&{(f & (Ambiguity.NotAType|Ambiguity.HasAttrs|Ambiguity.Tuple)) == 0}
						{f = 0;}
						subject:=Expr(RP(p, EP.Prefix), ref f)
						{
							if ((f & Ambiguity.TypeSuffix) != 0)
								Error(subject, "Syntax error: data type not expected here");
							r = F.Call(S.Cast, subject, r);
						}
					|	{	// not a cast
							if ((f & Ambiguity.Tuple) == 0)
								r = F.InParens(r);
						}
					)
				)
			/	t:="(" ")" &("=" | "=>")
				{f = Ambiguity.AllowUnassignedVarDecl;}
				{r = ExprOrTupleInside(t, ref f, true);}
			/	t:="(" ")"
				{f = 0;}
				{r = ExprOrTupleInside(t, ref f, true);}
			)	{return r;}
		];

		LNode ExprOrTupleInside(Token t, ref Ambiguity f, bool saveParensIfNotTuple)
		{
			var c = t.Children;
			Debug.Assert(c != null); // "()", "[]" and "{}" always have children
			if (c.Count == 0) {
				f.Tuple = true;
				return F.@void; // "()" is the void literal
			}
			Down(t);
			f = Ambiguity.ExpectCast;
			r = Up(ExprOrTuple(StartExpr, f));
			if (saveParensIfNotTuple && (f & Ambiguity.Tuple) == 0)
				r = F.InParens(r);
			return r;
		}

		LNode ExprOrTuple(ref Ambiguity f) ==> @[
			first:=Expr(StartExpr, ref f);
			(	{Ambiguity f0 = f; RWList<LNode> list = null; LNode next;}
				(	',' 
					{f=f0;}
					(	next=Expr(StartExpr, ref f)
					|	{next=F._Missing;}
					)
					{
						list = list ?? new RWList<LNode> {first};
						list.Add(next);
						f |= Ambiguity.Tuple;
					}
				)*   {return F.Call(S.Tuple, list.ToRVList());}
			/	_ => {return r;}
			)
		];
			
		bool IsNewCastOp(int li)
		{
			var c = LT(li).Children;
			if (c != null && c.Count != 0)
				return IsNewCastOp(c[0].Type);
		}
		bool IsNewCastOp(TT tt)
		{
			return tt == TT.@is || tt == TT.@as || tt == TT.@using || tt == TT.PtrArrow;
		}
		
	*/
		

	/*
		LNode EventDecl ==> @[
			t:="event" {FlushIds(0);}
			GatherStartingIds
			(	&{_startingIds.Count>=2} r:=FinishPropertyDecl(true) {return r;}
			|	{return Error(t, "Syntax error: 'event' is missing data type or name afterward");}
			)
		];

		LNode DelegateDecl ==> @[
			t:="delegate" {FlushIds(0);}
			GatherStartingIds
			(	&{_startingIds.Count>=2} r:=FinishMethodDecl(true) {return r;}
			|	{return Error(t, "Syntax error: 'delegate' is missing data type or name afterward");}
			)
		];
	*/

	/*
		static readonly Symbol __trait = GSymbol.Get("#trait");
		static readonly Symbol __alias = GSymbol.Get("#alias");
		LNode FinishNonKeywordSpaceDecl ==> @[
			{int i;}
			&{(i=NonKeywordSpaceDeclKeywordIndex()) != -1}
			=> (
				{	// Backtrack if necessary, then flush word attrs
					int c = _startingIds.Count;
					if (i + 2 < c) {
						_inputPosition = _startingIds[i+2].A;
						_startingIds.Resize(i+2);
					}
					FlushIds(2);
					Symbol kind = _startingIds[0].B.Name; // _trait or _alias
					Symbol kind2 = (kind == _trait ? __trait : __alias);
				}
				{LNode name;}
				(	&{kind==_alias} =>
					name=FinishExprStmt()
				|	{Debug.Assert(_kind==_trait);}
					name=_startingIds[1].B;
				)
				bases:=BaseListOpt
				WhereClausesOpt(ref name)
				(	';'               {return F.Call(kind2, name, bases);}
				|	body:=BracedBlock {return F.Call(kind2, name, bases, body);}
				)
			)
		];
	*/

	/*
		int NonKeywordSpaceDeclKeywordIndex()
		{
			// Non-space decls like "partial trait X {...}" will normally have 
			// the word 'trait' or 'alias' as the second-to-last word in 
			// _startingIds. However, in the case of "trait X<T> where T : class",
			// the word 'trait' comes earlier. This method figures that out.
			LNode id;
			Symbol name;
			for (int i = 0, c = _startingIds.Count - 1; i < c; i++)
				if ((id = _startingIds[0].B).IsIdent && 
					((name = id.Name) == _trait || name == _alias)
					return i;
			return -1;
		}
	*/
	}};
}
